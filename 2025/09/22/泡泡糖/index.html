<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>桃之夭夭 | 桃之夭夭</title><meta name="author" content="bistutzyy"><meta name="copyright" content="bistutzyy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 需求分析本次程序设计实践所做的实验项目主要是通过开发工具和 Jar 指令运行泡泡糖项目，体验泡泡糖项目的显示、消除、移动和积分等业务功能。 1.1 项目设计思路要设计出一款合格甚至优秀的游戏，在项目设计方面应该围绕游戏的可玩性，界面的可视性两方面出发。 1.1.1**可玩性**以我们所做的项目泡泡糖为例，可玩性体现在它的上手简单（只需要点击相同的泡泡糖便可消除），但复杂的运行逻辑又使它的形">
<meta property="og:type" content="article">
<meta property="og:title" content="桃之夭夭">
<meta property="og:url" content="https://bistutzyy.github.io/2025/09/22/%E6%B3%A1%E6%B3%A1%E7%B3%96/index.html">
<meta property="og:site_name" content="桃之夭夭">
<meta property="og:description" content="第一章 需求分析本次程序设计实践所做的实验项目主要是通过开发工具和 Jar 指令运行泡泡糖项目，体验泡泡糖项目的显示、消除、移动和积分等业务功能。 1.1 项目设计思路要设计出一款合格甚至优秀的游戏，在项目设计方面应该围绕游戏的可玩性，界面的可视性两方面出发。 1.1.1**可玩性**以我们所做的项目泡泡糖为例，可玩性体现在它的上手简单（只需要点击相同的泡泡糖便可消除），但复杂的运行逻辑又使它的形">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/1.png">
<meta property="article:published_time" content="2025-09-22T15:13:00.760Z">
<meta property="article:modified_time" content="2025-09-23T04:08:39.367Z">
<meta property="article:author" content="bistutzyy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://bistutzyy.github.io/2025/09/22/%E6%B3%A1%E6%B3%A1%E7%B3%96/",
  "image": "https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/1.png",
  "datePublished": "2025-09-22T15:13:00.760Z",
  "dateModified": "2025-09-23T04:08:39.367Z",
  "author": [
    {
      "@type": "Person",
      "name": "bistutzyy",
      "url": "https://bistutzyy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://bistutzyy.github.io/2025/09/22/%E6%B3%A1%E6%B3%A1%E7%B3%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'medium_zoom',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '桃之夭夭',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">桃之夭夭</span></a><a class="nav-page-title" href="/"><span class="site-name">桃之夭夭</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Untitled</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-09-22T15:13:00.760Z" title="Created 2025-09-22 23:13:00">2025-09-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-23T04:08:39.367Z" title="Updated 2025-09-23 12:08:39">2025-09-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>52mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="第一章-需求分析"><a href="#第一章-需求分析" class="headerlink" title="第一章 需求分析"></a><strong>第一章</strong> <strong>需求分析</strong></h1><p>本次程序设计实践所做的实验项目主要是通过开发工具和 Jar 指令运行泡泡糖项目，体验泡泡糖项目的显示、消除、移动和积分等业务功能。</p>
<h2 id="1-1-项目设计思路"><a href="#1-1-项目设计思路" class="headerlink" title="1.1 项目设计思路"></a><strong>1.1</strong> <strong>项目设计思路</strong></h2><p>要设计出一款合格甚至优秀的游戏，在项目设计方面应该围绕游戏的可玩性，界面的可视性两方面出发。</p>
<h3 id="1-1-1-可玩性"><a href="#1-1-1-可玩性" class="headerlink" title="1.1.1**可玩性**"></a><strong>1.1.1**</strong>可玩性**</h3><p>以我们所做的项目泡泡糖为例，可玩性体现在它的上手简单（只需要点击相同的泡泡糖便可消除），但复杂的运行逻辑又使它的形式十分丰富，同时我们所加入的特有的关卡设计也让这个游戏更符合当下青年想要挑战的心理。</p>
<p>这款泡泡糖的可玩性的突出之处在于简单的消除设计和丰富的关卡设计和积分奖励。</p>
<p>消除设计思路：点击屏幕上任意一个“泡泡糖”，与之相连的同颜色泡泡糖也会一并消除。因此在写消除方面的代码时，需要找到所有靠近点击目标的同色样式，需要反复利用循环来完成我们的设计。但是在前端界面却能十分简单地展示，这就是泡泡糖的可玩性。</p>
<p>关卡设计和积分奖励思路：通过计算每局游戏的得分，来判断玩家是否能够通过关卡。同时在每次通关时我们还会给予玩家一定的通关积分奖励，这样一方面降低了玩家的通关难度，另一方面也让玩家更有动力玩我们这款泡泡糖游戏。</p>
<h3 id="1-1-2-可视性"><a href="#1-1-2-可视性" class="headerlink" title="1.1.2 可视性"></a><strong>1.1.2</strong> <strong>可视性</strong></h3><p>单一的游戏展示界面会让玩家很快感受到无聊，从而降低对泡泡糖游戏的兴趣，因此，我们为泡泡糖的主界面设计了不同的主题风格，而切换主题的方式也相当简便，进一步完善了游戏的整体。</p>
<p>展示如下：</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=""/></div></div>
<div class="img-wrap"><div class="img-bg"><img class="img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%AD%98%E5%82%A8/01/1.1.2.01.png"/></div></div>
<div class="img-wrap"><div class="img-bg"><img class="img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%AD%98%E5%82%A8/01/1.1.2.02.jpg"/></div></div>
<h2 id="1-2-玩家分析"><a href="#1-2-玩家分析" class="headerlink" title="1.2 玩家分析"></a><strong>1.2</strong> <strong>玩家分析</strong></h2><p>设计一款游戏首先要明确定位玩家群体，根据玩家对游戏的期望和需求进行游戏的设计和调整。因此，在软件实际开发前的准备工作中，玩家分析是十分关键的一步。</p>
<p>以《消灭泡泡糖》这款游戏时为例，该游戏是为了做出一个耐玩有趣的休闲类消除小游戏，供玩家娱乐消遣。以下是一些包含的功能：</p>
<ol>
<li>随机泡泡糖：在完成每一关的挑战之后，系统将自动补全随机显示的各种颜色的泡泡糖；</li>
<li>主题切换功能：玩家在进行游戏时，可以选择不同的主题进行，以此来增强游戏的个性化元素；</li>
<li>目标分数的显示：玩家在开始每一关游戏时，可以知道本关游戏的目标分数，在消除泡泡糖的过程当中，会显示所得总分，让玩家清楚的看到自己的分数和目标分数；</li>
<li>额外奖励积分：当每一关不存在可消灭的泡泡糖之后，可以进一步判断剩余泡泡糖是否可以进行额外的奖励机制。</li>
</ol>
<p>在后续《消灭泡泡糖》的设计中，也主要围绕这些功能来展开并完善。</p>
<h1 id="第二章-概要设计"><a href="#第二章-概要设计" class="headerlink" title="第二章 概要设计"></a><strong>第二章</strong> <strong>概要设计</strong></h1><h2 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a><strong>2.1</strong> <strong>设计思路</strong></h2><p>任何一个项目在实际开发前，都要有一个明确的思路和整体框架的设计，正如本项目目录所显示的那样，对于《消灭泡泡糖》的设计，我的思路是：</p>
<p>①设计一个精美的界面和一个完整的游戏框架；</p>
<p>②显示10*10的泡泡糖矩阵</p>
<p>③消除泡泡糖（获取待消除的泡泡糖和封装待消除的泡泡糖）</p>
<p>④泡泡糖的移动（移动垂直方向上和水平方向上的泡泡糖）</p>
<p>⑤显示关卡积分（更新关卡分数和实现积分规则）</p>
<p>根据上述描述设计的简单点的流程图：</p>
<h2 id="2-2-游戏流程与整体框架（以及重点UML类图）"><a href="#2-2-游戏流程与整体框架（以及重点UML类图）" class="headerlink" title="2.2 游戏流程与整体框架（以及重点UML类图）"></a><strong>2.2</strong> <strong>游戏流程与整体框架（以及重点UML类图）</strong></h2><h3 id="2-2-1-游戏流程"><a href="#2-2-1-游戏流程" class="headerlink" title="2.2.1 游戏流程"></a><strong>2.2.1</strong> <strong>游戏流程</strong></h3><p>游戏流程（文字）：</p>
<p>1.开始：玩家点击 “开始消除泡泡糖”。</p>
<p>2.执行消除操作。</p>
<p>3.判断是否消除：</p>
<p>（1）是→计算得分→显示得分→判断是否通关：</p>
<p>① 是→通关提示→刷新界面到下一关→回到执行消除操作；</p>
<p>② 否→回到执行消除操作。</p>
<p>（2）否→判断是否还能消除：</p>
<p>① 是→回到执行消除操作；</p>
<p>② 否→判断是否没通关可能：</p>
<p> 是→游戏结束；</p>
<p> 否→回到执行消除操作。</p>
<p>流程图如下所示：</p>
<h3 id="2-2-2-整体框架"><a href="#2-2-2-整体框架" class="headerlink" title="2.2.2 整体框架"></a><strong>2.2.2</strong> <strong>整体框架</strong></h3><p>本消灭泡泡糖游戏项目以Java作为核心开发语言，依托<strong>JavaFX</strong>技术实现游戏功能设计与界面渲染，同时由元素，主题和控制器搭建了整体架构，确保代码模块化、逻辑清晰，便于开发维护与功能扩展。</p>
<p>1.模型：泡泡糖元素类Star（包含了泡泡糖的颜色、位置等信息）、MovedStar、得分等等</p>
<p>2.主题：src-rex.layout-main_layout.fxml文件文件</p>
<p>3.控制器：主要在MainForm文件中，设计了事件处理对象，负责相应玩家的输入，随之调整模型和视图。后续泡泡糖的消除和移动会广泛应用这方面。</p>
<h3 id="2-2-3-重点UML类图展示"><a href="#2-2-3-重点UML类图展示" class="headerlink" title="2.2.3 重点UML类图展示"></a><strong>2.2.3 重点UML类图展示</strong></h3><h1 id="第三章-泡泡糖的显示"><a href="#第三章-泡泡糖的显示" class="headerlink" title="第三章 泡泡糖的显示"></a><strong>第三章</strong> <strong>泡泡糖的显示</strong></h1><h2 id="3-1-显示泡泡糖（定位PRJ-BU2-JAVA-002）"><a href="#3-1-显示泡泡糖（定位PRJ-BU2-JAVA-002）" class="headerlink" title="3.1 显示泡泡糖（定位PRJ-BU2-JAVA-002）"></a><strong>3.1</strong> <strong>显示泡泡糖（定位PRJ-BU2-JAVA-002）</strong></h2><p>核心组件：</p>
<p>UML类图绘制：</p>
<h3 id="3-1-1-创建《消灭泡泡糖》实体类"><a href="#3-1-1-创建《消灭泡泡糖》实体类" class="headerlink" title="3.1.1 创建《消灭泡泡糖》实体类"></a><strong>3.1.1</strong> <strong>创建《消灭泡泡糖》实体类</strong></h3><p>本场景需要实现在游戏界面上呈现5个不同颜色的泡泡糖，并且泡泡糖的位置由坐标决定，具体操作需要创建Star,Position等实体类，并设置其中的成员方法和成员变量，同时还需要创建枚举类型StarType（Star类中）,并且要添加返回整数类型的公共函数vaule。</p>
<p>以下是关键代码摘取：</p>
<p><strong>Position类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package cn.campsg.practical.bubble.entity;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public class Position &#123;</span><br><span class="line"></span><br><span class="line">  private int row;  // 行索引</span><br><span class="line"></span><br><span class="line">  private int column; // 列索引</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public Position() &#123; // 无参构造方法</span><br><span class="line"></span><br><span class="line">​    super();</span><br><span class="line"></span><br><span class="line">​    // TODO Auto-generated constructor stub</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public Position(int row, int column) &#123; // 有参构造方法，初始化行列位置</span><br><span class="line"></span><br><span class="line">​    super();</span><br><span class="line"></span><br><span class="line">​    this.row = row;  // 赋值行索引</span><br><span class="line"></span><br><span class="line">​    this.column = column; // 赋值列索引</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public int getRow() &#123; // 获取行索引</span><br><span class="line"></span><br><span class="line">​    return row;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public void setRow(int row) &#123; // 设置行索引</span><br><span class="line"></span><br><span class="line">​    this.row = row;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public int getColumn() &#123; // 获取列索引</span><br><span class="line"></span><br><span class="line">​    return column;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public void setColumn(int column) &#123; // 设置列索引</span><br><span class="line"></span><br><span class="line">​    this.column = column;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Star类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Star &#123;</span><br><span class="line"></span><br><span class="line">  private Position position = null; // 泡泡糖在二维坐标系中的位置，初始化为null</span><br><span class="line"></span><br><span class="line">  private StarType type = null; // 泡泡糖的类型（颜色），初始化为null</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  public Position getPosition() &#123; // 获取泡泡糖的位置</span><br><span class="line"></span><br><span class="line">​    return position;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setPosition(Position position) &#123; // 设置泡泡糖的位置</span><br><span class="line"></span><br><span class="line">​    this.position = position;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StarType getType() &#123; // 获取泡泡糖的类型</span><br><span class="line"></span><br><span class="line">​    return type;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setType(StarType type) &#123; // 设置泡泡糖的类型</span><br><span class="line"></span><br><span class="line">​    this.type = type;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>StarType类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public enum StarType&#123;</span><br><span class="line"></span><br><span class="line">  BLUE(0),GREEN(1),YELLOW(2),RED(3),PURPLE(4); // 定义星星类型枚举值及对应数值</span><br><span class="line"></span><br><span class="line">  private int value = 0; // 存储枚举值对应的数值</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // 枚举构造函数，初始化枚举值对应的数值</span><br><span class="line"></span><br><span class="line">  private StarType(int value)&#123;</span><br><span class="line"></span><br><span class="line">​    this.value = value;</span><br><span class="line"></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // 枚举成员方法，返回当前枚举值对应的数值</span><br><span class="line"></span><br><span class="line">  public int value()&#123;</span><br><span class="line"></span><br><span class="line">​    return this.value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public StarList createStars() &#123;</span><br><span class="line"></span><br><span class="line">​    Star star1 = new Star(); // 创建第一个泡泡糖对象</span><br><span class="line"></span><br><span class="line">​    star1.setPosition(new Position(0,0)); // 设置第一个泡泡糖位置为(0,0)</span><br><span class="line"></span><br><span class="line">​    star1.setType(StarType.BLUE); // 设置第一个泡泡糖类型为蓝色</span><br><span class="line"></span><br><span class="line">​    Star star2 = new Star(); // 创建第二个泡泡糖对象</span><br><span class="line"></span><br><span class="line">​    star2.setPosition(new Position(1,1)); // 设置第二个泡泡糖位置为(1,1)</span><br><span class="line"></span><br><span class="line">​    star2.setType(StarType.GREEN); // 设置第二个泡泡糖类型为绿色</span><br><span class="line"></span><br><span class="line">​    // 打印第一个泡泡糖的列、行坐标及类型</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;(&quot;+star1.getPosition().getColumn()+&quot;)&quot;+&quot;,&quot;+&quot;(&quot;+(star1.getPosition().getRow()+&quot;)&quot;+&quot; &quot;+&quot;-&quot;+&quot; &quot;+star1.getType()));</span><br><span class="line"></span><br><span class="line">​    // 打印第二个泡泡糖的列、行坐标及类型</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;(&quot;+star2.getPosition().getColumn()+&quot;)&quot;+&quot;,&quot;+&quot;(&quot;+(star2.getPosition().getRow()+&quot;)&quot;+&quot; &quot;+&quot;-&quot;+&quot; &quot;+star2.getType()));</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下所示：</strong></p>
<h3 id="3-1-2-优化《消灭泡泡糖》实体类"><a href="#3-1-2-优化《消灭泡泡糖》实体类" class="headerlink" title="3.1.2 优化《消灭泡泡糖》实体类"></a><strong>3.1.2</strong> <strong>优化《消灭泡泡糖》实体类</strong></h3><p>在3.1.1中，Star类中的StarType枚举不够完善，枚举类型只能使用，不能实现类型转换。当前任务主要是为枚举添加转换函数，实现数值向枚举的转换。（0-&gt;BLUE）</p>
<p><strong>StarType类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public enum StarType&#123;</span><br><span class="line">		BLUE(0),GREEN(1),YELLOW(2),RED(3),PURPLE(4); // 定义星星类型枚举值及对应数值</span><br><span class="line">		private int value = 0; // 存储枚举值对应的数值</span><br><span class="line">		</span><br><span class="line">		// 枚举构造函数，初始化枚举值对应的数值</span><br><span class="line">		private StarType(int value)&#123;</span><br><span class="line">			this.value = value;</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">		// 枚举成员方法，返回当前枚举值对应的数值</span><br><span class="line">		public int value()&#123;</span><br><span class="line">			return this.value;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 静态方法，根据数值获取对应的星星类型</span><br><span class="line">		public static StarType valueOf(int value)&#123;</span><br><span class="line">			switch(value)&#123;</span><br><span class="line">			case 0:</span><br><span class="line">				return BLUE;</span><br><span class="line">			case 1:</span><br><span class="line">				return GREEN;</span><br><span class="line">			case 2:</span><br><span class="line">				return YELLOW;</span><br><span class="line">			case 3:</span><br><span class="line">				return RED;</span><br><span class="line">			case 4:</span><br><span class="line">				return PURPLE;</span><br><span class="line">			default:</span><br><span class="line">return null; // 数值不匹配时返回null</span><br><span class="line">		  &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public StarList createStars() &#123;</span><br><span class="line">       Star star1 = new Star(); // 创建第一个泡泡糖对象</span><br><span class="line">       star1.setPosition(new Position(0,0)); // 设置第一个泡泡糖位置为(0,0)</span><br><span class="line">       star1.setType(StarType.BLUE); // 设置第一个泡泡糖类型为蓝色</span><br><span class="line">       Star star2 = new Star(); // 创建第二个泡泡糖对象</span><br><span class="line">       star2.setPosition(new Position(1,1)); // 设置第二个泡泡糖位置为(1,1)</span><br><span class="line">       star2.setType(StarType.GREEN); // 设置第二个泡泡糖类型为绿色</span><br><span class="line">       System.out.println(StarType.BLUE.value()); // 打印蓝色泡泡糖类型对应的数值(0)</span><br><span class="line">       System.out.println(StarType.valueOf(1)); // 打印数值1对应的泡泡糖类型(GREEN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下所示：</strong></p>
<h3 id="3-1-3-游戏界面呈现泡泡糖"><a href="#3-1-3-游戏界面呈现泡泡糖" class="headerlink" title="3.1.3 游戏界面呈现泡泡糖"></a><strong>3.1.3</strong> <strong>游戏界面呈现泡泡糖</strong></h3><p>3.1.1和3.1.2均利用了控制台显示了泡泡糖数据，当前任务将会把Star类数据显示在游戏界面上。</p>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public StarList createStars() &#123;</span><br><span class="line">		StarList starList = new StarList(); // 初始化泡泡糖列表</span><br><span class="line">		// 向列表中添加不同位置和类型的泡泡糖</span><br><span class="line">		starList.add(new Star(new Position(0,0),StarType.BLUE)); // 添加位置(0,0)的蓝色泡泡糖</span><br><span class="line">		starList.add(new Star(new Position(1,1),StarType.RED)); // 添加位置(1,1)的红色泡泡糖</span><br><span class="line">		starList.add(new Star(new Position(2,2),StarType.YELLOW)); // 添加位置(2,2)的黄色泡泡糖</span><br><span class="line">		starList.add(new Star(new Position(3,3),StarType.GREEN)); // 添加位置(3,3)的绿色泡泡糖</span><br><span class="line">starList.add(new Star(new Position(4,4),StarType.PURPLE)); // 添加位置(4,4)的紫色泡泡糖</span><br><span class="line">	      </span><br><span class="line">		return starList; // 返回创建好的泡泡糖列表</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下所示：</strong></p>
<h2 id="3-2-随机显示泡泡糖（定位PRJ-BU2-JAVA-003）"><a href="#3-2-随机显示泡泡糖（定位PRJ-BU2-JAVA-003）" class="headerlink" title="3.2 随机显示泡泡糖（定位PRJ-BU2-JAVA-003）"></a><strong>3.2</strong> <strong>随机显示泡泡糖（定位PRJ-BU2-JAVA-003）</strong></h2><p>在1.1中我们已经实现在界面上的“指定位置显示指定颜色的泡泡糖”，在这一模块将进一步利用for循环的嵌套使用以及随机数的产生等方法在界面上显示随机产生的10*10的泡泡糖矩阵。</p>
<p>核心组件：</p>
<p>UML类图绘制：</p>
<h3 id="3-2-1-显示一行泡泡糖"><a href="#3-2-1-显示一行泡泡糖" class="headerlink" title="3.2.1 显示一行泡泡糖"></a><strong>3.2.1</strong> <strong>显示一行泡泡糖</strong></h3><p><strong>createStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 循环遍历行中的每一列（从第0列到MAX_ROW_SIZE-1列）</span><br><span class="line">for(int j=0; j&lt;MAX_ROW_SIZE; j++)&#123;</span><br><span class="line">    // 创建一个新的红泡泡糖对象，位置在第0行第j列</span><br><span class="line">    // Position(0,j)表示坐标位置，第一个参数是行索引，第二个参数是列索引</span><br><span class="line">    // StarType.RED指定泡泡糖的类型为红色（此处类型名仍为StarType，可根据实际情况调整）</span><br><span class="line">    Star star = new Star(new Position(0,j), StarType.RED);</span><br><span class="line">    </span><br><span class="line">    // 将创建的泡泡糖对象添加到泡泡糖列表中</span><br><span class="line">    stars.add(star);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="3-2-2-显示10-10泡泡糖矩阵"><a href="#3-2-2-显示10-10泡泡糖矩阵" class="headerlink" title="3.2.2 显示10 * 10泡泡糖矩阵"></a><strong>3.2.2</strong> <strong>显示10 * 10泡泡糖矩阵</strong></h3><p><strong>createStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 外层循环遍历每一列（从第0列到MAX_COLUMN_SIZE-1列）</span><br><span class="line">for(int i = 0; i &lt; MAX_COLUMN_SIZE; i++)&#123;</span><br><span class="line">    // 内层循环遍历当前列中的每一行（从第0行到MAX_ROW_SIZE-1行）</span><br><span class="line">    for(int j = 0; j &lt; MAX_ROW_SIZE; j++)&#123;</span><br><span class="line">        // 创建一个新的泡泡糖对象，位置在第j行第i列</span><br><span class="line">        // Position(j,i)表示坐标位置，第一个参数是行索引，第二个参数是列索引</span><br><span class="line">        // StarType.valueOf(3)指定泡泡糖的类型为值为3对应的类型（此处类型名仍为StarType，可根据实际情况调整）</span><br><span class="line">        Star star = new Star(new Position(j, i), StarType.valueOf(3));</span><br><span class="line"> </span><br><span class="line">        // 将创建的泡泡糖对象添加到泡泡糖列表中</span><br><span class="line">        stars.add(star);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="3-2-3-随机显示10-10泡泡糖矩阵"><a href="#3-2-3-随机显示10-10泡泡糖矩阵" class="headerlink" title="3.2.3 随机显示10 * 10泡泡糖矩阵"></a><strong>3.2.3</strong> <strong>随机显示10 * 10泡泡糖矩阵</strong></h3><p>3.2.1和3.2.2实现了在界面上呈现10 * 10泡泡糖矩阵的效果，但当前游戏界面只能固定显示100个红色泡泡糖。本任务将实现泡泡糖的颜色的随机设置，满足游戏的基本要素。</p>
<p><strong>createStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public StarList createStars() &#123;</span><br><span class="line">    // 创建一个新的泡泡糖列表对象，用于存储所有生成的泡泡糖</span><br><span class="line">    StarList stars = new StarList();</span><br><span class="line">    </span><br><span class="line">    // 外层循环遍历每一行（从第0行到MAX_ROW_SIZE-1行）</span><br><span class="line">    for(int row = 0; row &lt; MAX_ROW_SIZE; row++) &#123;</span><br><span class="line">        // 内层循环遍历当前行中的每一列（从第0列到MAX_COLUMN_SIZE-1列）</span><br><span class="line">        for(int column = 0; column &lt; MAX_COLUMN_SIZE; column++) &#123;</span><br><span class="line">            // 创建一个新的泡泡糖对象</span><br><span class="line">            Star star = new Star();</span><br><span class="line">            </span><br><span class="line">            // 设置泡泡糖的位置为当前行和列对应的坐标（row行，column列）</span><br><span class="line">            star.setPosition(new Position(row,column));</span><br><span class="line">            </span><br><span class="line">            // 生成一个随机索引值，范围是0到StarService.STAR_TYPES-1</span><br><span class="line">            // 用于随机选择泡泡糖的类型</span><br><span class="line">            int typeIndex = (int)(Math.random()*StarService.STAR_TYPES);</span><br><span class="line">            </span><br><span class="line">            // 根据随机生成的索引设置泡泡糖的类型</span><br><span class="line">            star.setType(StarType.valueOf(typeIndex));</span><br><span class="line">            </span><br><span class="line">            // 将创建好的泡泡糖添加到泡泡糖列表中</span><br><span class="line">            stars.add(star);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    // 返回包含所有生成泡泡糖的列表</span><br><span class="line">    return stars; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h1 id="第四章-泡泡糖的显示"><a href="#第四章-泡泡糖的显示" class="headerlink" title="第四章 泡泡糖的显示"></a><strong>第四章</strong> <strong>泡泡糖的显示</strong></h1><h2 id="4-1-获得待消除的泡泡糖-（定位PRJ-BU2-JAVA-004）"><a href="#4-1-获得待消除的泡泡糖-（定位PRJ-BU2-JAVA-004）" class="headerlink" title="4.1 获得待消除的泡泡糖 （定位PRJ-BU2-JAVA-004）"></a><strong>4.1 获得待消除的泡泡糖 （定位PRJ-BU2-JAVA-004）</strong></h2><p>核心组件：</p>
<p>UML类图绘制：</p>
<h3 id="4-1-1-泡泡糖克隆函数"><a href="#4-1-1-泡泡糖克隆函数" class="headerlink" title="4.1.1 泡泡糖克隆函数"></a><strong>4.1.1</strong> <strong>泡泡糖克隆函数</strong></h3><p><strong>clone函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Star clone(Star star) &#123;</span><br><span class="line">    // 创建一个新的泡泡糖对象作为克隆结果</span><br><span class="line">    Star ret = new Star();</span><br><span class="line">    </span><br><span class="line">    // 复制原泡泡糖的位置信息，创建新的Position对象以避免引用共享</span><br><span class="line">    ret.setPosition(new Position(star.getPosition().getRow(), star.getPosition().getColumn()));</span><br><span class="line">    </span><br><span class="line">    // 复制原泡泡糖的类型信息</span><br><span class="line">    ret.setType(star.getType());</span><br><span class="line">    </span><br><span class="line">    // 返回克隆得到的新泡泡糖对象</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 创建一个位置在(5,5)的红色泡泡糖对象s1</span><br><span class="line">    Star s1 = new Star(new Position(5,5), StarType.RED);</span><br><span class="line">    </span><br><span class="line">    // 使用工具类克隆s1得到新的泡泡糖对象s2</span><br><span class="line">    Star s2 = StarsUtil.clone(s1);</span><br><span class="line">    </span><br><span class="line">    // 打印原泡泡糖对象信息</span><br><span class="line">    System.out.println(&quot;原泡泡糖对象为：&quot; + s1);</span><br><span class="line">    </span><br><span class="line">    // 打印克隆得到的泡泡糖对象信息</span><br><span class="line">    System.out.println(&quot;克隆泡泡糖对象为：&quot; + s2);</span><br><span class="line">    </span><br><span class="line">    // 比较两个泡泡糖对象是否为同一个对象（地址比较）</span><br><span class="line">    System.out.println(&quot;两对象是否一致：&quot; + s1.equals(s2));</span><br><span class="line">    </span><br><span class="line">    // 比较两个泡泡糖对象的坐标是否相同</span><br><span class="line">    System.out.println(&quot;两对象的坐标对象是否一致：&quot; + s1.getPosition().equals(s2.getPosition()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="4-1-2-查询某个泡泡糖左侧同色泡泡糖"><a href="#4-1-2-查询某个泡泡糖左侧同色泡泡糖" class="headerlink" title="4.1.2 查询某个泡泡糖左侧同色泡泡糖"></a><strong>4.1.2</strong> <strong>查询某个泡泡糖左侧同色泡泡糖</strong></h3><p>实现流程（右侧，顶部和底部与左侧相似，因此只列举一个作为参考）：</p>
<p><strong>左侧消除代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 检查左侧是否有可匹配的泡泡糖</span><br><span class="line">if (column &gt; 0) &#123;</span><br><span class="line">    // 获取当前位置左侧相邻（同一行，前一列）的泡泡糖</span><br><span class="line">    Star star = sList.lookup(row, column - 1);</span><br><span class="line">    </span><br><span class="line">    // 判断左侧泡泡糖是否存在、未被标记清除且与当前泡泡糖类型相同</span><br><span class="line">    if ((star != null) &amp;&amp; (!clearStars.existed(star)) &amp;&amp; (star.getType() == type)) &#123;</span><br><span class="line">        // 将左侧泡泡糖的克隆添加到待清除列表中</span><br><span class="line">        clearStars.add(StarsUtil.clone(star));</span><br><span class="line">        // 递归查找与左侧泡泡糖相连的其他可清除泡泡糖</span><br><span class="line">        lookupByPath(star, sList, clearStars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="4-1-3-查询某个泡泡糖右侧同色泡泡糖"><a href="#4-1-3-查询某个泡泡糖右侧同色泡泡糖" class="headerlink" title="4.1.3 查询某个泡泡糖右侧同色泡泡糖"></a><strong>4.1.3</strong> <strong>查询某个泡泡糖右侧同色泡泡糖</strong></h3><p><strong>右侧消除代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 检查右侧是否有可匹配的泡泡糖</span><br><span class="line">if (column &lt; StarService.MAX_COLUMN_SIZE - 1) &#123;</span><br><span class="line">    Star star = sList.lookup(row, column + 1);</span><br><span class="line">    </span><br><span class="line">    if ((star != null) &amp;&amp; (!clearStars.existed(star)) &amp;&amp; (star.getType() == type)) &#123;</span><br><span class="line">        clearStars.add(StarsUtil.clone(star));</span><br><span class="line">        lookupByPath(star, sList, clearStars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="4-1-4-查询某个泡泡糖顶部泡泡糖"><a href="#4-1-4-查询某个泡泡糖顶部泡泡糖" class="headerlink" title="4.1.4 查询某个泡泡糖顶部泡泡糖"></a><strong>4.1.4</strong> <strong>查询某个泡泡糖顶部泡泡糖</strong></h3><p><strong>顶部消除代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 检查顶部是否有可匹配的泡泡糖</span><br><span class="line">if(row &gt; 0) &#123;</span><br><span class="line">        	Star star = sList.lookup(row - 1, column);</span><br><span class="line">        	if((star != null)&amp;&amp;(!clearStars.existed(star))&amp;&amp;(star.getType() == type)) &#123;</span><br><span class="line">        		clearStars.add(StarsUtil.clone(star));</span><br><span class="line">        		lookupByPath(star,sList,clearStars);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="4-1-5-查询某个泡泡糖底部泡泡糖"><a href="#4-1-5-查询某个泡泡糖底部泡泡糖" class="headerlink" title="4.1.5 查询某个泡泡糖底部泡泡糖"></a><strong>4.1.5</strong> <strong>查询某个泡泡糖底部泡泡糖</strong></h3><p><strong>底部消除代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 检查底部是否有可匹配的泡泡糖</span><br><span class="line">if(row &lt; StarService.MAX_ROW_SIZE - 1) &#123;</span><br><span class="line">        	Star star = sList.lookup(row + 1, column);</span><br><span class="line">        	if((star != null)&amp;&amp;(!clearStars.existed(star))&amp;&amp;(star.getType() == type)) &#123;</span><br><span class="line">        		clearStars.add(StarsUtil.clone(star));</span><br><span class="line">        		lookupByPath(star,sList,clearStars);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h2 id="4-2-封装待移动的泡泡糖（定位PRJ-BU2-JAVA-005）"><a href="#4-2-封装待移动的泡泡糖（定位PRJ-BU2-JAVA-005）" class="headerlink" title="4.2 封装待移动的泡泡糖（定位PRJ-BU2-JAVA-005）"></a><strong>4.2</strong> <strong>封装待移动的泡泡糖（定位PRJ-BU2-JAVA-005）</strong></h2><p>核心组件：</p>
<p>UML类图绘制：</p>
<h3 id="4-2-1-创建待移动泡泡糖实体类"><a href="#4-2-1-创建待移动泡泡糖实体类" class="headerlink" title="4.2.1 创建待移动泡泡糖实体类"></a><strong>4.2.1</strong> <strong>创建待移动泡泡糖实体类</strong></h3><p>创建一个用于描述【待移动泡泡糖】实体类，不但具有泡泡糖的所有特性（位置，类型），同时还具有自己独立的属性:待移动位置（坐标），两个实体类（待移动泡泡糖和泡泡糖）之间存在继承关系。</p>
<p><strong>MoveStar类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// MovedStar类继承是Star的子类，用于表示有移动轨迹的泡泡糖</span><br><span class="line">public class MovedStar extends Star &#123;</span><br><span class="line">    // 记录泡泡糖移动后的位置</span><br><span class="line">    private Position movedPosition;</span><br><span class="line"></span><br><span class="line">    // 构造方法：创建有初始位置、类型和移动后位置的MovedStar对象</span><br><span class="line">    // 参数分别为：初始位置、泡泡糖类型、移动后的位置</span><br><span class="line">    public MovedStar(Position position, StarType type, Position movedPosition) &#123;</span><br><span class="line">        // 调用父类构造方法，初始化泡泡糖的初始位置和类型</span><br><span class="line">        super(new Position(position.getRow(), position.getColumn()), type);</span><br><span class="line">        // 设置泡泡糖移动后的位置</span><br><span class="line">        this.movedPosition = movedPosition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无参构造方法：创建默认的MovedStar对象</span><br><span class="line">    public MovedStar() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取泡泡糖移动后的位置</span><br><span class="line">    public Position getMovedPosition() &#123;</span><br><span class="line">        return movedPosition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置泡泡糖移动后的位置</span><br><span class="line">    public void setMovedPosition(Position movedPosition) &#123;</span><br><span class="line">        this.movedPosition = movedPosition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 创建泡泡糖的初始位置对象（坐标为(0,0)）</span><br><span class="line">    Position position = new Position(0, 0);</span><br><span class="line">    // 创建泡泡糖的移动目标位置对象（坐标为(1,1)）</span><br><span class="line">    Position movedPosition = new Position(1, 1);</span><br><span class="line">    // 设置泡泡糖的颜色类型为红色</span><br><span class="line">    StarType type = StarType.RED;</span><br><span class="line">    System.out.println(&quot;泡泡糖原位置：&quot; + position);</span><br><span class="line">    System.out.println(&quot;泡泡糖移动的目标位置：&quot; + movedPosition);</span><br><span class="line">    System.out.println(&quot;泡泡糖的颜色为：&quot; + type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="4-2-2-实体类的文本化输出函数"><a href="#4-2-2-实体类的文本化输出函数" class="headerlink" title="4.2.2 实体类的文本化输出函数"></a><strong>4.2.2</strong> <strong>实体类的文本化输出函数</strong></h3><p>本节将利用面向对象三要素中的多态重写特性体验实体继承的优势。</p>
<p>重写<strong>Position类</strong>的toString方法代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return &quot;position:&quot;+&quot;(&quot;+getRow()+&quot;,&quot;+getColumn()+&quot;)&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重写<strong>Star类</strong>的toString方法代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return position.toString()+&quot;,&quot;+&quot;type:&quot;+getType();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重写<strong>MovedStar类</strong>的toString方法代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return super.toString()+&quot;\nnew&quot;+ movedPosition.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] a) &#123;</span><br><span class="line">    // 创建一个可移动泡泡糖对象</span><br><span class="line">    MovedStar movedStar = new MovedStar();</span><br><span class="line">    </span><br><span class="line">    // 设置泡泡糖的初始位置为(0,0)</span><br><span class="line">    movedStar.setPosition(new Position(0, 0));</span><br><span class="line">    </span><br><span class="line">    // 设置泡泡糖的移动后位置为(1,1)</span><br><span class="line">    movedStar.setMovedPosition(new Position(1, 1));</span><br><span class="line">    </span><br><span class="line">    // 设置泡泡糖的类型为蓝色</span><br><span class="line">    movedStar.setType(StarType.BLUE);</span><br><span class="line">    </span><br><span class="line">    // 打印输出该可移动泡泡糖的信息（具体内容取决于toString()方法的实现）</span><br><span class="line">    System.out.println(movedStar.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="4-2-3-实现移动泡泡糖封装"><a href="#4-2-3-实现移动泡泡糖封装" class="headerlink" title="4.2.3 实现移动泡泡糖封装"></a><strong>4.2.3</strong> <strong>实现移动泡泡糖封装</strong></h3><p>本节用于计算并获取垂直方向的【待移动泡泡糖】。</p>
<p><strong>getYMovedStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public StarList getYMovedStars(StarList clearStars, StarList currentStarList) &#123;</span><br><span class="line">    // 创建一个用于存储移动泡泡糖的列表</span><br><span class="line">    StarList movedStarList = new StarList();</span><br><span class="line">    </span><br><span class="line">    // 从第6行开始向上遍历至第0行</span><br><span class="line">    for(int row = 6; row &gt;= 0; row--) &#123;</span><br><span class="line">        // 获取当前行第0列的泡泡糖</span><br><span class="line">        Star star = currentStarList.lookup(row, 0);</span><br><span class="line">        </span><br><span class="line">        // 计算泡泡糖移动后的位置（当前行+2，列不变仍为0）</span><br><span class="line">        Position movedPosition = new Position(row + 2, 0);</span><br><span class="line">        </span><br><span class="line">        // 获取泡泡糖的原始位置</span><br><span class="line">        Position position = new Position(star.getPosition().getRow(), star.getPosition().getColumn());</span><br><span class="line">        </span><br><span class="line">        // 创建移动泡泡糖对象，包含原始位置、类型和移动后位置</span><br><span class="line">        MovedStar movedStar = new MovedStar(position, star.getType(), movedPosition);</span><br><span class="line">        </span><br><span class="line">        // 将移动泡泡糖添加到列表中</span><br><span class="line">        movedStarList.add(movedStar);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回包含所有移动泡泡糖的列表</span><br><span class="line">    return movedStarList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h2 id="4-3-体验接口解耦特性（定位PRJ-BU2-JAVA-006）"><a href="#4-3-体验接口解耦特性（定位PRJ-BU2-JAVA-006）" class="headerlink" title="4.3 体验接口解耦特性（定位PRJ-BU2-JAVA-006）"></a><strong>4.3</strong> <strong>体验接口解耦特性（定位PRJ-BU2-JAVA-006）</strong></h2><p>核心组件：</p>
<p>UML类图：</p>
<h3 id="4-3-1-创建服务测试类"><a href="#4-3-1-创建服务测试类" class="headerlink" title="4.3.1 创建服务测试类"></a><strong>4.3.1</strong> <strong>创建服务测试类</strong></h3><p><strong>StarServiceTester类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class StarServiceTester implements StarService &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建StarServiceTester实例作为测试服务对象</span><br><span class="line">        StarService serviceTester = new StarServiceTester();</span><br><span class="line">        </span><br><span class="line">        // 调用createStars方法创建泡泡糖列表</span><br><span class="line">        StarList starList = serviceTester.createStars();</span><br><span class="line">        </span><br><span class="line">        // 打印输出创建的泡泡糖列表信息</span><br><span class="line">        System.out.println(starList);    </span><br><span class="line">    &#125;</span><br><span class="line">    @Override    </span><br><span class="line">    public StarList createStars() &#123;</span><br><span class="line">        // 创建一个新的泡泡糖列表</span><br><span class="line">        StarList starList = new StarList();</span><br><span class="line">        </span><br><span class="line">        // 创建位置在(0,0)的蓝色泡泡糖并添加到列表</span><br><span class="line">        Star star1 = new Star(new Position(0,0), StarType.BLUE);</span><br><span class="line">        starList.add(star1);</span><br><span class="line">        </span><br><span class="line">        // 创建位置在(0,1)的绿色泡泡糖并添加到列表</span><br><span class="line">        Star star2 = new Star(new Position(0,1), StarType.GREEN);</span><br><span class="line">        starList.add(star2);</span><br><span class="line">        </span><br><span class="line">        // 创建位置在(1,0)的紫色泡泡糖并添加到列表</span><br><span class="line">        Star star3 = new Star(new Position(1,0), StarType.PURPLE);</span><br><span class="line">        starList.add(star3);</span><br><span class="line">        </span><br><span class="line">        // 创建位置在(1,1)的黄色泡泡糖并添加到列表</span><br><span class="line">        Star star4 = new Star(new Position(1,1), StarType.YELLOW);</span><br><span class="line">        starList.add(star4);</span><br><span class="line">        </span><br><span class="line">        // 创建位置在(0,2)的红色泡泡糖并添加到列表</span><br><span class="line">        Star star5 = new Star(new Position(0,2), StarType.RED);</span><br><span class="line">        starList.add(star5);</span><br><span class="line">        </span><br><span class="line">        // 返回创建好的泡泡糖列表</span><br><span class="line">        return starList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public StarList tobeClearedStars(Star base, StarList sList) &#123;</span><br><span class="line">        // 待实现：获取需要清除的泡泡糖列表</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public StarList getYMovedStars(StarList clearStars, StarList currentStarList) &#123;</span><br><span class="line">        // 待实现：获取在Y轴方向移动的泡泡糖列表</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public StarList getXMovedStars(StarList currentStarList) &#123;</span><br><span class="line">        // 待实现：获取在X轴方向移动的泡泡糖列表</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean tobeEliminated(StarList currentStarList) &#123;</span><br><span class="line">        // 待实现：判断是否有需要消除的泡泡糖</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public StarList getAwardStarList(StarList currentStarList) &#123;</span><br><span class="line">        // 待实现：获取奖励泡泡糖列表</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="4-3-2-实现界面泡泡糖显示及通过动态接口切换"><a href="#4-3-2-实现界面泡泡糖显示及通过动态接口切换" class="headerlink" title="4.3.2 实现界面泡泡糖显示及通过动态接口切换"></a><strong>4.3.2</strong> <strong>实现界面泡泡糖显示及通过动态接口切换</strong></h3><p>因两节关联性较高，所以放在一起进行整理。</p>
<p><strong>initGameStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private void initGameStars(AnchorPane root) &#123;</span><br><span class="line">    // 获取窗体中用于显示泡泡糖的区域（游戏面板）</span><br><span class="line">mStarForm = (AnchorPane) root.lookup(&quot;#game_pane&quot;);</span><br><span class="line"></span><br><span class="line">    // 获取泡泡糖服务实例，用于创建和管理泡泡糖</span><br><span class="line">    StarService service = this.getStarService();</span><br><span class="line">    // 通过服务创建当前游戏的泡泡糖列表</span><br><span class="line">    mCurretStars = service.createStars();</span><br><span class="line">    // 遍历泡泡糖列表，为每个泡泡糖创建并配置显示控件</span><br><span class="line">    for (int i = 0; i &lt; mCurretStars.size(); i++) &#123;</span><br><span class="line">        // 从集合中获取当前泡泡糖对象</span><br><span class="line">        Star star = mCurretStars.get(i);</span><br><span class="line">        </span><br><span class="line">        // 创建用于显示泡泡糖的标签控件</span><br><span class="line">        Label starFrame = new Label();</span><br><span class="line">        // 设置标签的宽高为48x48像素</span><br><span class="line">        starFrame.setPrefWidth(48);</span><br><span class="line">        starFrame.setPrefHeight(48);</span><br><span class="line">        </span><br><span class="line">        // 获取当前泡泡糖的行列坐标</span><br><span class="line">        int row = star.getPosition().getRow();</span><br><span class="line">        int col = star.getPosition().getColumn();</span><br><span class="line">        </span><br><span class="line">        // 设置标签的ID，格式为&quot;s+列号+行号&quot;</span><br><span class="line">        starFrame.setId(&quot;s&quot; + col + row);</span><br><span class="line">        // 存储用户数据为&quot;列号;行号&quot;格式</span><br><span class="line">        starFrame.setUserData(col + &quot;;&quot; + row);</span><br><span class="line">        </span><br><span class="line">        // 设置标签在面板中的位置（根据行列计算坐标）</span><br><span class="line">        starFrame.setLayoutX(col * 48);</span><br><span class="line">        starFrame.setLayoutY(row * 48);</span><br><span class="line">        // 根据泡泡糖的类型设置不同的样式类（控制显示颜色）</span><br><span class="line">        switch (star.getType().value()) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                starFrame.getStyleClass().add(&quot;blue_star&quot;);  // 蓝色泡泡糖样式</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                starFrame.getStyleClass().add(&quot;green_star&quot;); // 绿色泡泡糖样式</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                starFrame.getStyleClass().add(&quot;yellow_star&quot;);// 黄色泡泡糖样式</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                starFrame.getStyleClass().add(&quot;red_star&quot;);   // 红色泡泡糖样式</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                starFrame.getStyleClass().add(&quot;purple_star&quot;);// 紫色泡泡糖样式</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 将配置好的泡泡糖显示控件添加到游戏面板中</span><br><span class="line">        mStarForm.getChildren().add(starFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过动态接口切换（定位<strong>bean.conf</strong>）</p>
<p>第一个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service=cn.campsg.practical.bubble.service.StarServiceTester</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<p>第二个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service=cn.campsg.practical.bubble.service.StarServiceImpl</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<h2 id="4-4-体验接口隔离性（定位PRJ-BU2-JAVA-007）"><a href="#4-4-体验接口隔离性（定位PRJ-BU2-JAVA-007）" class="headerlink" title="4.4 体验接口隔离性（定位PRJ-BU2-JAVA-007）"></a><strong>4.4</strong> <strong>体验接口隔离性（定位PRJ-BU2-JAVA-007）</strong></h2><p>核心组件：</p>
<p>UML类图：</p>
<h3 id="4-4-1-处理泡泡糖点击事件"><a href="#4-4-1-处理泡泡糖点击事件" class="headerlink" title="4.4.1 处理泡泡糖点击事件"></a><strong>4.4.1</strong> <strong>处理泡泡糖点击事件</strong></h3><p>创建Lable控件【点击事件处理类】，并实现【点击事件】处理接口EventHandler。</p>
<p><strong>StartEventHandler类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class StartEventHandler implements EventHandler&lt;MouseEvent&gt;&#123;</span><br><span class="line">public void handle(MouseEvent event) &#123;</span><br><span class="line">					// TODO Auto-generated method stub</span><br><span class="line">					//获取被点击的泡泡糖显示控件</span><br><span class="line">					Label starFrame = (Label) event.getTarget()；		</span><br><span class="line">					//将试图转换为泡泡糖对象</span><br><span class="line">					Star base = StarFormUtils.convert(starFrame);</span><br><span class="line">					 System.out.println(base);</span><br><span class="line">StartEventHandler sta = new StartEventHandler(getStarService());</span><br><span class="line">			starFrame.setOnMouseClicked(sta);</span><br><span class="line">			// 将泡泡糖加入到窗体中显示泡泡糖的区域</span><br><span class="line">			mStarForm.getChildren().add(starFrame);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示</strong></p>
<h3 id="4-4-2-实现点击-消除效果（不考虑移动）"><a href="#4-4-2-实现点击-消除效果（不考虑移动）" class="headerlink" title="4.4.2 实现点击-消除效果（不考虑移动）"></a><strong>4.4.2</strong> <strong>实现点击-消除效果（不考虑移动）</strong></h3><p>点击界面上任意泡泡糖，界面实现消除泡泡糖操作。</p>
<p><strong>StartEventHandler类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 泡泡糖点击事件处理器</span><br><span class="line">class StartEventHandler implements EventHandler&lt;MouseEvent&gt; &#123;</span><br><span class="line">    // 泡泡糖业务服务对象</span><br><span class="line">    private StarService starService = null;</span><br><span class="line">    </span><br><span class="line">    // 构造方法：传入泡泡糖业务服务</span><br><span class="line">    public StartEventHandler(StarService starService) &#123;</span><br><span class="line">        this.starService = starService;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    @Override</span><br><span class="line">    public void handle(MouseEvent event) &#123;</span><br><span class="line">        // 获取被点击的泡泡糖显示控件</span><br><span class="line">        Label starFrame = (Label)event.getTarget();</span><br><span class="line">        // 转换为泡泡糖数据对象</span><br><span class="line">        Star base = StarFormUtils.convert(starFrame);</span><br><span class="line">        // 打印被点击的泡泡糖信息</span><br><span class="line">        System.out.println(base);</span><br><span class="line">        </span><br><span class="line">        // 调用服务获取待清除的泡泡糖列表</span><br><span class="line">        StarList starlist = this.starService.tobeClearedStars(base, mCurretStars);	</span><br><span class="line">        // 无待清除泡泡糖则返回</span><br><span class="line">        if (starlist == null || starlist.size() == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历处理待清除泡泡糖</span><br><span class="line">        else &#123;</span><br><span class="line">            for(int i=0;i&lt;starlist.size();i++)&#123;</span><br><span class="line">                Star star = starlist.get(i);</span><br><span class="line">                // 找到对应的显示控件</span><br><span class="line">                Label lable = StarFormUtils.findFrame(star, mStarForm);</span><br><span class="line">                // 执行清除动画</span><br><span class="line">                StarAnimation.clearStarLable(mStarForm, lable);</span><br><span class="line">                // 在数据列表中标记为空</span><br><span class="line">                mCurretStars.setNull(star.getPosition().getRow(), star.getPosition().getColumn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h1 id="第五章-泡泡糖的移动"><a href="#第五章-泡泡糖的移动" class="headerlink" title="第五章 泡泡糖的移动"></a><strong>第五章</strong> <strong>泡泡糖的移动</strong></h1><h2 id="5-1-移动垂直方向的泡泡糖（一）（定位PRJ-BU2-JAVA-010）"><a href="#5-1-移动垂直方向的泡泡糖（一）（定位PRJ-BU2-JAVA-010）" class="headerlink" title="5.1 移动垂直方向的泡泡糖（一）（定位PRJ-BU2-JAVA-010）"></a><strong>5.1</strong> <strong>移动垂直方向的泡泡糖（一）（定位PRJ-BU2-JAVA-010）</strong></h2><p>核心组件：</p>
<p>UML类图：</p>
<h3 id="5-1-1-交换两个泡泡糖"><a href="#5-1-1-交换两个泡泡糖" class="headerlink" title="5.1.1 交换两个泡泡糖"></a><strong>5.1.1</strong> <strong>交换两个泡泡糖</strong></h3><p>本场景采用冒泡排序算法来实现，在实现前我们需要先完成排序算法的基础——交换函数。实现方法可参考下图：（<strong>交换对象时务必交换属性</strong>）</p>
<p><strong>swap类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    /*</span><br><span class="line">    Star star1 = new Star(new Position(0,0),Star.StarType.BLUE);</span><br><span class="line">    Star star2 = new Star(new Position(1,1),Star.StarType.GREEN);</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;交换前:preStar:&quot; + star1.toString() + &quot;  nextStar:&quot; + star2.toString());</span><br><span class="line">    </span><br><span class="line">    swap(star1,star2);</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;交换后:preStar:&quot; + star1.toString() + &quot;  nextStar:&quot; + star2.toString());</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    // 创建5个不同位置和类型的泡泡糖对象</span><br><span class="line">    Star star1 = new Star(new Position(2,0), Star.StarType.BLUE);</span><br><span class="line">    Star star2 = new Star(new Position(5,0), Star.StarType.GREEN);</span><br><span class="line">    Star star3 = new Star(new Position(9,0), Star.StarType.PURPLE);</span><br><span class="line">    Star star4 = new Star(new Position(3,0), Star.StarType.RED);</span><br><span class="line">    Star star5 = new Star(new Position(8,0), Star.StarType.YELLOW);</span><br><span class="line">    </span><br><span class="line">    // 创建泡泡糖列表并添加上述泡泡糖</span><br><span class="line">    StarList sList = new StarList();</span><br><span class="line">    sList.add(star1);</span><br><span class="line">    sList.add(star2);</span><br><span class="line">    sList.add(star3);</span><br><span class="line">    sList.add(star4);</span><br><span class="line">    sList.add(star5);</span><br><span class="line">    </span><br><span class="line">    // 打印排序前的泡泡糖列表</span><br><span class="line">    System.out.println(&quot;排序前：starList:&quot;);</span><br><span class="line">    for(int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        System.out.print(sList.get(i).toString() + &quot;   ,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(sList.get(4).toString());</span><br><span class="line">    </span><br><span class="line">    // 对泡泡糖列表进行排序</span><br><span class="line">    sort(sList);</span><br><span class="line">    </span><br><span class="line">    // 打印排序后的泡泡糖列表</span><br><span class="line">    System.out.println(&quot;\n排序后：starList:&quot;);</span><br><span class="line">    for(int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        System.out.print(sList.get(i).toString() + &quot;   ,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(sList.get(4).toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] a) &#123;</span><br><span class="line">    // 创建第一个泡泡糖：位置(0,0)、类型蓝色</span><br><span class="line">    Star preStar = new Star(new Position(0, 0), StarType.BLUE);</span><br><span class="line">    // 创建第二个泡泡糖：位置(1,1)、类型绿色</span><br><span class="line">    Star nextStar = new Star(new Position(1, 1), StarType.GREEN);</span><br><span class="line">    </span><br><span class="line">    // 打印交换前第一个泡泡糖的信息</span><br><span class="line">    System.out.println(preStar);</span><br><span class="line">    // 打印交换前第二个泡泡糖的信息</span><br><span class="line">    System.out.println(nextStar);</span><br><span class="line">    </span><br><span class="line">    // 调用工具类方法，交换两个泡泡糖的数据（如位置、类型）</span><br><span class="line">    StarsUtil.swap(preStar, nextStar);</span><br><span class="line">    </span><br><span class="line">    // 打印交换后第一个泡泡糖的信息</span><br><span class="line">    System.out.println(preStar);</span><br><span class="line">    // 打印交换后第二个泡泡糖的信息</span><br><span class="line">    System.out.println(nextStar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="5-1-2-泡泡糖集合的排序"><a href="#5-1-2-泡泡糖集合的排序" class="headerlink" title="5.1.2 泡泡糖集合的排序"></a><strong>5.1.2</strong> <strong>泡泡糖集合的排序</strong></h3><p>对“待消除泡泡糖”进行排序操作。</p>
<p><strong>sort类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 对泡泡糖列表进行排序（按泡泡糖所在行号升序排序）</span><br><span class="line">public static void sort(StarList starList) &#123;</span><br><span class="line">    // 外层循环：控制排序轮次（共需 size-1 轮，每轮确定一个最大行号的泡泡糖位置）</span><br><span class="line">    for (int i = 0; i &lt; starList.size() - 1; i++) &#123;</span><br><span class="line">        // 内层循环：每轮比较相邻泡泡糖，将大的行号往后移（每轮少比较 i 个已排好的元素）</span><br><span class="line">        for (int j = 0; j &lt; starList.size() - i - 1; j++) &#123;</span><br><span class="line">            // 获取当前位置和下一个位置的泡泡糖</span><br><span class="line">            Star preStar = starList.get(j);</span><br><span class="line">            Star nextStar = starList.get(j + 1);</span><br><span class="line">            </span><br><span class="line">            // 比较两个泡泡糖的行号：若前一个行号大于后一个，交换两者数据</span><br><span class="line">            if (preStar.getPosition().getRow() &gt; nextStar.getPosition().getRow()) &#123;</span><br><span class="line">                swap(preStar, nextStar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sort算法说明：</p>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 创建泡泡糖列表对象，用于存储多个泡泡糖</span><br><span class="line">    StarList starList = new StarList();</span><br><span class="line">    </span><br><span class="line">    // 向列表中添加5个不同行位置（列均为0）、不同颜色的泡泡糖</span><br><span class="line">    starList.add(new Star(new Position(2, 0), StarType.BLUE));    // 行2、列0，蓝色泡泡糖</span><br><span class="line">    starList.add(new Star(new Position(5, 0), StarType.GREEN));   // 行5、列0，绿色泡泡糖</span><br><span class="line">    starList.add(new Star(new Position(9, 0), StarType.PURPLE));  // 行9、列0，紫色泡泡糖</span><br><span class="line">    starList.add(new Star(new Position(3, 0), StarType.RED));     // 行3、列0，红色泡泡糖</span><br><span class="line">    starList.add(new Star(new Position(8, 0), StarType.YELLOW));  // 行8、列0，黄色泡泡糖</span><br><span class="line">    </span><br><span class="line">    // 打印排序前的泡泡糖列表（展示初始顺序）</span><br><span class="line">    System.out.println(starList);</span><br><span class="line">    </span><br><span class="line">    // 调用工具类方法，按泡泡糖的行号升序排序</span><br><span class="line">    StarsUtil.sort(starList);</span><br><span class="line">    </span><br><span class="line">    // 打印排序后的泡泡糖列表（展示按行号从小到大的顺序）</span><br><span class="line">    System.out.println(starList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="5-1-3-移动垂直方向的泡泡糖"><a href="#5-1-3-移动垂直方向的泡泡糖" class="headerlink" title="5.1.3 移动垂直方向的泡泡糖"></a><strong>5.1.3</strong> <strong>移动垂直方向的泡泡糖</strong></h3><p>通过getYMovedStars函数实现获取“垂直方向待移动泡泡糖”的集合。并在界面上实现泡泡糖的消除与移动。</p>
<p>具体流程：</p>
<p><strong>GetYMovedStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public StarList getYMovedStars(StarList clearStars, StarList currentStarList) &#123;</span><br><span class="line">    // 若无可清除的泡泡糖，直接返回null</span><br><span class="line">    if (clearStars == null || clearStars.size() == 0)</span><br><span class="line">        return null;</span><br><span class="line">    </span><br><span class="line">    // 对可清除的泡泡糖列表进行排序</span><br><span class="line">    StarsUtil.sort(clearStars);</span><br><span class="line">    </span><br><span class="line">    // 创建存储移动泡泡糖的列表</span><br><span class="line">    StarList moveStars = new StarList();</span><br><span class="line">    // 记录移动跨度（受清除泡泡糖影响的偏移量）</span><br><span class="line">    int span = 0;</span><br><span class="line">    // 处理的列号（固定为0列）</span><br><span class="line">    int column = 0;</span><br><span class="line">    // 从可清除泡泡糖的最大行号开始处理</span><br><span class="line">    int startPosition = clearStars.lastElement().getPosition().getRow();</span><br><span class="line">    </span><br><span class="line">    // 从最大行号向上遍历至第0行</span><br><span class="line">    for (int row = startPosition; row &gt;= 0; row--) &#123;</span><br><span class="line">        // 获取当前行列的泡泡糖</span><br><span class="line">        Star star = currentStarList.lookup(row, column);</span><br><span class="line">        // 若当前位置无泡泡糖，退出循环</span><br><span class="line">        if (star == null)</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">        // 若当前泡泡糖是待清除的，增加跨度并跳过</span><br><span class="line">        if (clearStars.existed(star)) &#123;</span><br><span class="line">            span++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 创建移动泡泡糖对象</span><br><span class="line">        MovedStar movedStar = new MovedStar();</span><br><span class="line">        // 设置原始位置</span><br><span class="line">        movedStar.setPosition(new Position(star.getPosition().getRow(), star.getPosition().getColumn()));</span><br><span class="line">        // 设置泡泡糖类型</span><br><span class="line">        movedStar.setType(star.getType());</span><br><span class="line">        // 设置移动后的位置（原始行号+跨度）</span><br><span class="line">        movedStar.setMovedPosition(new Position(star.getPosition().getRow() + span, star.getPosition().getColumn()));</span><br><span class="line">        </span><br><span class="line">        // 将移动泡泡糖添加到列表</span><br><span class="line">        moveStars.add(movedStar);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return moveStars;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h2 id="5-2-移动垂直方向的泡泡糖（二）（定位PRJ-BU2-JAVA-011）"><a href="#5-2-移动垂直方向的泡泡糖（二）（定位PRJ-BU2-JAVA-011）" class="headerlink" title="5.2 移动垂直方向的泡泡糖（二）（定位PRJ-BU2-JAVA-011）"></a><strong>5.2 移动垂直方向的泡泡糖（二）（定位PRJ-BU2-JAVA-011）</strong></h2><p>核心组件：</p>
<p>UML类图：</p>
<h3 id="5-2-1根据坐标和位置查找泡泡糖"><a href="#5-2-1根据坐标和位置查找泡泡糖" class="headerlink" title="5.2.1根据坐标和位置查找泡泡糖"></a><strong>5.2.1</strong>根据坐标和位置查找泡泡糖</h3><p>本节对ArrayList进行扩展，实现根据行，列值查找泡泡糖的方法&amp;利用Java的重载机制，实现根据位置【Position】查找泡泡糖的方法。</p>
<p>根据坐标寻找的<strong>lookup</strong>函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 根据行号和列号查找对应的泡泡糖</span><br><span class="line">public Star lookup(int row, int column) &#123;</span><br><span class="line">    // 遍历列表中的所有泡泡糖</span><br><span class="line">    for (int i = 0; i &lt; super.size(); i++) &#123;</span><br><span class="line">        // 跳过空元素</span><br><span class="line">        if (super.get(i) == null) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 获取当前泡泡糖的位置信息</span><br><span class="line">        Star currentStar = super.get(i);</span><br><span class="line">        Position pos = currentStar.getPosition();</span><br><span class="line">        </span><br><span class="line">        // 若行列号匹配，返回找到的泡泡糖</span><br><span class="line">        if (pos.getRow() == row &amp;&amp; pos.getColumn() == column) &#123;</span><br><span class="line">            return currentStar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 未找到匹配的泡泡糖，返回null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据位置寻找的<strong>lookup</strong>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 根据位置对象查找查找对应的泡泡糖</span><br><span class="line">// 调用重载方法，传入位置的行号和列号进行查找</span><br><span class="line">public Star lookup(Position position) &#123;</span><br><span class="line">    return lookup(position.getRow(), position.getColumn());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-判断泡泡糖是否存在"><a href="#5-2-2-判断泡泡糖是否存在" class="headerlink" title="5.2.2 判断泡泡糖是否存在"></a><strong>5.2.2</strong> <strong>判断泡泡糖是否存在</strong></h3><p>利用上一节的<strong>lookup</strong>函数，实现判断泡泡糖是否存在于集合的函数<strong>existed</strong>。</p>
<p><strong>existed类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 判断指定泡泡糖是否存在于列表中</span><br><span class="line">public boolean existed(Star star) &#123;</span><br><span class="line">    // 若传入的泡泡糖为null，直接返回不存在</span><br><span class="line">    if (star == null)</span><br><span class="line">        return false;</span><br><span class="line">    </span><br><span class="line">    // 根据泡泡糖的位置查找列表中是否有匹配的泡泡糖</span><br><span class="line">    Star ret = lookup(star.getPosition());</span><br><span class="line">    </span><br><span class="line">    // 若找到匹配的泡泡糖则返回true，否则返回false</span><br><span class="line">    return ret == null ? false : true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h2 id="5-3-移动垂直方向上的泡泡糖（三）（定位PRJ-BU2-JAVA-012）"><a href="#5-3-移动垂直方向上的泡泡糖（三）（定位PRJ-BU2-JAVA-012）" class="headerlink" title="5.3 移动垂直方向上的泡泡糖（三）（定位PRJ-BU2-JAVA-012）"></a><strong>5.3 移动垂直方向上的泡泡糖（三）（定位PRJ-BU2-JAVA-012）</strong></h2><p>核心组件：</p>
<p>UML类图：</p>
<h3 id="5-3-1-更新集合的排序算法"><a href="#5-3-1-更新集合的排序算法" class="headerlink" title="5.3.1 更新集合的排序算法"></a><strong>5.3.1</strong> <strong>更新集合的排序算法</strong></h3><p>本节在前两个任务的基础上针对“待消除泡泡糖”的排序由单列变多列。</p>
<p>实现流程：</p>
<p><strong>sort类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 对泡泡糖列表进行排序（先按列号升序，列号相同则按行号升序）</span><br><span class="line">public static void sort(StarList starList) &#123;</span><br><span class="line">    // 外层循环：控制排序轮次（共需 size 轮）</span><br><span class="line">    for (int i = 0; i &lt; starList.size(); i++) &#123;</span><br><span class="line">        // 内层循环：每轮比较相邻元素，将较大元素后移（每轮少比较 i 个已排好的元素）</span><br><span class="line">        for (int j = 0; j &lt; starList.size() - i - 1; j++) &#123;</span><br><span class="line">            // 获取当前位置和下一个位置的泡泡糖</span><br><span class="line">            Star preStar = starList.get(j);</span><br><span class="line">            Star nextStar = starList.get(j + 1);</span><br><span class="line">            </span><br><span class="line">            // 比较列号：若前一个列号大于后一个，交换两个泡泡糖</span><br><span class="line">            if (preStar.getPosition().getColumn() &gt; nextStar.getPosition().getColumn()) &#123;</span><br><span class="line">                swap(preStar, nextStar);</span><br><span class="line">            &#125; </span><br><span class="line">            // 若列号相同，比较行号：若前行号大于后行号，交换两个泡泡糖</span><br><span class="line">            else if (preStar.getPosition().getColumn() == nextStar.getPosition().getColumn()) &#123;</span><br><span class="line">                if (preStar.getPosition().getRow() &gt; nextStar.getPosition().getRow()) &#123;</span><br><span class="line">                    swap(preStar, nextStar);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 创建泡泡糖列表</span><br><span class="line">    StarList starlist = new StarList();</span><br><span class="line">    </span><br><span class="line">    // 添加不同位置和类型的泡泡糖</span><br><span class="line">    starlist.add(new Star(new Position(2, 3), StarType.BLUE));    // 位置(2,3)，蓝</span><br><span class="line">    starlist.add(new Star(new Position(1, 5), StarType.GREEN));   // 位置(1,5)，绿</span><br><span class="line">    starlist.add(new Star(new Position(0, 9), StarType.PURPLE));  // 位置(0,9)，紫</span><br><span class="line">    starlist.add(new Star(new Position(0, 3), StarType.RED));     // 位置(0,3)，红</span><br><span class="line">    starlist.add(new Star(new Position(0, 8), StarType.YELLOW));  // 位置(0,8)，黄</span><br><span class="line">    </span><br><span class="line">    // 打印排序前的列表</span><br><span class="line">    System.out.println(starlist);</span><br><span class="line">    </span><br><span class="line">    // 按规则排序（先列号升序，列号相同则行号升序）</span><br><span class="line">    sort(starlist);</span><br><span class="line">    </span><br><span class="line">    // 打印排序后的列表</span><br><span class="line">    System.out.println(starlist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="5-3-2-待消除泡泡糖的排序与分组"><a href="#5-3-2-待消除泡泡糖的排序与分组" class="headerlink" title="5.3.2 待消除泡泡糖的排序与分组"></a><strong>5.3.2</strong> <strong>待消除泡泡糖的排序与分组</strong></h3><p>为确保界面能够按照从左向右，从上到下的顺序移动所有“待移动的泡泡糖”，我们需要对已经排序完毕的“待移动泡泡糖”进行分组，分组后原本挤压在一个集合中的所有“待消除的泡泡糖”将会被按（列）组成多个“待消除的泡泡糖”集合，每个集合中的“待消除的泡泡糖”仅行号不同，列号均相同（如下）。</p>
<p><strong>group类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 按列号对泡泡糖列表进行分组，返回列号到对应列泡泡糖列表的映射</span><br><span class="line">public static Map&lt;Integer, StarList&gt; group(StarList starList) &#123;</span><br><span class="line">    // 创建存储分组结果的Map（键：列号，值：该列的泡泡糖列表）</span><br><span class="line">    Map&lt;Integer, StarList&gt; ret = new HashMap&lt;Integer, StarList&gt;();</span><br><span class="line">    </span><br><span class="line">    // 先对泡泡糖列表排序（确保同列泡泡糖连续）</span><br><span class="line">    sort(starList);</span><br><span class="line">    </span><br><span class="line">    // 遍历所有泡泡糖进行分组</span><br><span class="line">    for (int i = 0; i &lt; starList.size(); i++) &#123;</span><br><span class="line">        Star star = starList.get(i);</span><br><span class="line">        int column = star.getPosition().getColumn();</span><br><span class="line">        </span><br><span class="line">        // 若当前列号在Map中不存在，创建新列表并添加当前泡泡糖</span><br><span class="line">        if (!ret.containsKey(column)) &#123;</span><br><span class="line">            StarList list = new StarList();</span><br><span class="line">            list.add(star);</span><br><span class="line">            ret.put(column, list);</span><br><span class="line">        &#125; </span><br><span class="line">        // 若已存在该列号，直接将泡泡糖添加到对应列表</span><br><span class="line">        else &#123;</span><br><span class="line">            ret.get(column).add(star);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-获取垂直方向待移动泡泡糖"><a href="#5-3-3-获取垂直方向待移动泡泡糖" class="headerlink" title="5.3.3 获取垂直方向待移动泡泡糖"></a><strong>5.3.3</strong> <strong>获取垂直方向待移动泡泡糖</strong></h3><p>本节是在前面任务的基础上实现获得多列“垂直方向待移动泡泡糖”的功能。</p>
<p><strong>getYMovedStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 获取垂直方向需要移动的泡泡糖列表（处理因清除泡泡糖导致的下落逻辑）</span><br><span class="line">public StarList getYMovedStars(StarList clearStars, StarList currentStarList) &#123;</span><br><span class="line">    // 存储需要移动的泡泡糖</span><br><span class="line">    StarList movedStars = new StarList();</span><br><span class="line">    // 按列号分组存储待清除的泡泡糖</span><br><span class="line">    Map&lt;Integer, StarList&gt; groupStars = StarsUtil.group(clearStars);</span><br><span class="line">    // 遍历所有列</span><br><span class="line">    Iterator&lt;Integer&gt; keys = groupStars.keySet().iterator();</span><br><span class="line">    while (keys.hasNext()) &#123;</span><br><span class="line">        int column = keys.next();</span><br><span class="line">        // 获取当前列中待清除的泡泡糖列表</span><br><span class="line">        StarList starList = groupStars.get(column);</span><br><span class="line">        // 从当前列中最下方（最大行号）的待清除泡泡糖开始处理</span><br><span class="line">        int startPosition = starList.lastElement().getPosition().getRow();</span><br><span class="line">        // 记录下落跨度（受清除泡泡糖数量影响的偏移量）</span><br><span class="line">        int span = 0;</span><br><span class="line">        </span><br><span class="line">        // 从最下方待清除泡泡糖的行号向上遍历至第0行</span><br><span class="line">        for (int row = startPosition; row &gt;= 0; row--) &#123;</span><br><span class="line">            // 查找当前行列位置的泡泡糖</span><br><span class="line">            Star star = currentStarList.lookup(row, column);</span><br><span class="line">            // 若当前位置无泡泡糖，退出循环</span><br><span class="line">            if (star == null)</span><br><span class="line">                break;</span><br><span class="line">            </span><br><span class="line">            // 若当前泡泡糖是待清除的，增加下落跨度</span><br><span class="line">            if (clearStars.existed(star)) &#123;</span><br><span class="line">                span++;</span><br><span class="line">            &#125; </span><br><span class="line">            // 若不是待清除的，计算其移动后的位置并添加到列表</span><br><span class="line">            else &#123;</span><br><span class="line">                MovedStar movedStar = new MovedStar(</span><br><span class="line">                    star.getPosition(), </span><br><span class="line">                    star.getType(), </span><br><span class="line">                    new Position(row + span, column)  // 移动后的位置 = 原行号 + 下落跨度</span><br><span class="line">                );</span><br><span class="line">                movedStars.add(movedStar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return movedStars;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h2 id="5-4-移动水平方向的泡泡糖（定位PRJ-BU2-JAVA-013）"><a href="#5-4-移动水平方向的泡泡糖（定位PRJ-BU2-JAVA-013）" class="headerlink" title="5.4 移动水平方向的泡泡糖（定位PRJ-BU2-JAVA-013）"></a><strong>5.4</strong> <strong>移动水平方向的泡泡糖（定位PRJ-BU2-JAVA-013）</strong></h2><p>核心组件：</p>
<p>UML类图：</p>
<h3 id="5-4-1-获取被整列清空的泡泡糖集合"><a href="#5-4-1-获取被整列清空的泡泡糖集合" class="headerlink" title="5.4.1 获取被整列清空的泡泡糖集合"></a><strong>5.4.1</strong> <strong>获取被整列清空的泡泡糖集合</strong></h3><p>本节是根据界面泡泡糖矩阵，获取“被清空所有泡泡糖的列”集合。</p>
<p><strong>getNullColumns类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有底部为空的列（即最底行无泡泡糖的列）</span><br><span class="line">private List&lt;Integer&gt; getNullColumns(StarList currentStarList) &#123;</span><br><span class="line">    // 存储底部为空的列号</span><br><span class="line">    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    // 遍历所有列</span><br><span class="line">    for (int column = 0; column &lt; StarService.MAX_COLUMN_SIZE; column++) &#123;</span><br><span class="line">        // 查找当前列最底行（最大行号）的泡泡糖</span><br><span class="line">        Star star = currentStarList.lookup(StarService.MAX_ROW_SIZE - 1, column);</span><br><span class="line">        </span><br><span class="line">        // 若最底行无泡泡糖，记录该列号</span><br><span class="line">        if (star == null) &#123;</span><br><span class="line">            ret.add(column);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试类代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;nullIntegers=(ArrayList&lt;Integer&gt;)getNullColumns(currentStarList);</span><br><span class="line">		System.out.println(nullIntegers);</span><br><span class="line">		return null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="5-4-2-获取水平待移动泡泡糖"><a href="#5-4-2-获取水平待移动泡泡糖" class="headerlink" title="5.4.2 获取水平待移动泡泡糖"></a><strong>5.4.2</strong> <strong>获取水平待移动泡泡糖</strong></h3><p>本任务利用上一节计算获得的“整列被清空泡泡糖”的列号集合，获取水平待移动的泡泡糖的数量和移动步长。</p>
<p><strong>getXMovedStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 获取水平方向需要移动的泡泡糖列表（处理底部为空列导致的左移逻辑）</span><br><span class="line">public StarList getXMovedStars(StarList currentStarList) &#123;</span><br><span class="line">    /**************PRJ-BU2-JAVA-013 Task2  【2/2 Start】*************/</span><br><span class="line">    // 存储需要水平移动的泡泡糖</span><br><span class="line">    StarList movedStars = new StarList();</span><br><span class="line">    </span><br><span class="line">    // 获取所有底部为空的列（最底行无泡泡糖的列）</span><br><span class="line">    List&lt;Integer&gt; nullColumns = getNullColumns(currentStarList);</span><br><span class="line">    </span><br><span class="line">    // 若没有底部为空的列，无需移动，返回null</span><br><span class="line">    if (nullColumns == null || nullColumns.size() == 0)</span><br><span class="line">        return null;</span><br><span class="line">    </span><br><span class="line">    // 记录水平移动跨度（左侧空列的数量，决定右列泡泡糖左移的距离）</span><br><span class="line">    int span = 0;</span><br><span class="line">    </span><br><span class="line">    // 从第一个底部空列开始，遍历所有列</span><br><span class="line">    for (int column = nullColumns.get(0); column &lt; StarService.MAX_COLUMN_SIZE; column++) &#123;</span><br><span class="line">        // 若当前列是底部空列，增加移动跨度</span><br><span class="line">        if (nullColumns.contains(column)) &#123;</span><br><span class="line">            span++;</span><br><span class="line">        &#125; </span><br><span class="line">        // 若当前列不是底部空列，处理该列所有泡泡糖的左移</span><br><span class="line">        else &#123;</span><br><span class="line">            // 从当前列最底行向上遍历所有行</span><br><span class="line">            for (int row = StarService.MAX_ROW_SIZE - 1; row &gt;= 0; row--) &#123;</span><br><span class="line">                // 查找当前行列的泡泡糖</span><br><span class="line">                Star star = currentStarList.lookup(row, column);</span><br><span class="line">                </span><br><span class="line">                // 若当前行无泡泡糖，向上行继续查找（避免处理空行）</span><br><span class="line">                if (star == null)</span><br><span class="line">                    break;</span><br><span class="line">                </span><br><span class="line">                // 将普通泡泡糖转为移动泡泡糖对象</span><br><span class="line">                MovedStar mStar = StarsUtil.toMovedStar(star);</span><br><span class="line">                // 设置左移后的位置：原行号不变，原列号减去移动跨度</span><br><span class="line">                mStar.setMovedPosition(new Position(star.getPosition().getRow(), star.getPosition().getColumn() - span));</span><br><span class="line">                </span><br><span class="line">                // 将移动泡泡糖添加到结果列表</span><br><span class="line">                movedStars.add(mStar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return movedStars;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h1 id="第六章-通关分数与积分"><a href="#第六章-通关分数与积分" class="headerlink" title="第六章 通关分数与积分"></a><strong>第六章</strong> <strong>通关分数与积分</strong></h1><h2 id="6-1-更新关卡通关分数（定位PRJ-BU2-JAVA-014）"><a href="#6-1-更新关卡通关分数（定位PRJ-BU2-JAVA-014）" class="headerlink" title="6.1 更新关卡通关分数（定位PRJ-BU2-JAVA-014）"></a><strong>6.1</strong> <strong>更新关卡通关分数（定位PRJ-BU2-JAVA-014）</strong></h2><p>核心组件：</p>
<p>UML类图：</p>
<h3 id="6-1-1-获取初始通关分数"><a href="#6-1-1-获取初始通关分数" class="headerlink" title="6.1.1 获取初始通关分数"></a><strong>6.1.1</strong> <strong>获取初始通关分数</strong></h3><p>获取第一关的通关目标分数，该分数需要从配置文件中动态读取。</p>
<p><strong>Configuration类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Configuration &#123;</span><br><span class="line">    // 存储泡泡糖游戏的分数配置信息</span><br><span class="line">    private Score score = null;</span><br><span class="line">    // 分数配置文件路径，固定为&quot;score.conf&quot;</span><br><span class="line">    private final String CONF_PATH = &quot;score.conf&quot;;</span><br><span class="line"></span><br><span class="line">    public Configuration() &#123;</span><br><span class="line">        // 初始化分数对象</span><br><span class="line">        score = new Score();</span><br><span class="line">        BufferedReader bf = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取配置文件输入流并创建缓冲读取器</span><br><span class="line">            bf = new BufferedReader(new InputStreamReader(this.getClass().getClassLoader().getResourceAsStream(CONF_PATH)));</span><br><span class="line">            // 按行读取配置文件内容，依次设置泡泡糖游戏的各项分数参数</span><br><span class="line">            // 配置文件内容依次为：等级分数、步数、增量、长度</span><br><span class="line">            score.setLevelScore(Integer.parseInt(bf.readLine()));</span><br><span class="line">            score.setStep(Integer.parseInt(bf.readLine()));</span><br><span class="line">            score.setIncrement(Integer.parseInt(bf.readLine()));</span><br><span class="line">            score.setLength(Integer.parseInt(bf.readLine()));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // 读取配置文件发生IO异常时，将score置为null</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            score = null;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 确保缓冲读取器关闭，释放资源</span><br><span class="line">            if (bf != null)</span><br><span class="line">                try &#123;</span><br><span class="line">                    bf.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    // 关闭流发生异常时打印堆栈信息</span><br><span class="line">                    // TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取泡泡糖游戏的分数配置对象</span><br><span class="line">     * @return 分数配置对象，若加载失败则返回null</span><br><span class="line">     */</span><br><span class="line">    public Score getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ScoreServiceImpl implements ScoreService &#123;</span><br><span class="line">    // 配置对象，用于获取泡泡糖游戏的分数相关配置</span><br><span class="line">    private Configuration mConfiguration = null;</span><br><span class="line"></span><br><span class="line">    //构造方法，初始化配置对象</span><br><span class="line">    public ScoreServiceImpl()&#123;</span><br><span class="line">        mConfiguration = new Configuration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCurrentLevelScore() &#123;</span><br><span class="line">        // 通过配置对象获取分数配置，并返回当前关卡的通关分数</span><br><span class="line">        return mConfiguration.getScore().getLevelScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="6-1-2-更新关卡通关分数"><a href="#6-1-2-更新关卡通关分数" class="headerlink" title="6.1.2 更新关卡通关分数"></a><strong>6.1.2</strong> <strong>更新关卡通关分数</strong></h3><p>数据实现：</p>
<p><strong>nextScoreByLevel类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int nextScoreByLevel(int nextLevel) &#123;</span><br><span class="line">    // 获取泡泡糖游戏的分数配置信息</span><br><span class="line">    Score score = mConfiguration.getScore();</span><br><span class="line">    </span><br><span class="line">    // 若配置信息获取失败（score为null），返回0</span><br><span class="line">    if(score == null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 计算下一关的通关分数：</span><br><span class="line">    // 公式 = 当前等级分数 + ((下一关等级-1)/关卡长度) * 分数增量 + 步数</span><br><span class="line">    // 其中(下一关等级-1)/关卡长度用于根据关卡进度计算递增倍数</span><br><span class="line">    score.setLevelScore(score.getLevelScore() + (nextLevel - 1) / score.getLength() * score.getIncrement() + score.getStep());</span><br><span class="line">    </span><br><span class="line">    // 返回计算后的下一关通关分数</span><br><span class="line">    return score.getLevelScore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h2 id="6-2-实现泡泡糖的积分规则（定位PRJ-BU2-JAVA-015）"><a href="#6-2-实现泡泡糖的积分规则（定位PRJ-BU2-JAVA-015）" class="headerlink" title="6.2 实现泡泡糖的积分规则（定位PRJ-BU2-JAVA-015）"></a><strong>6.2</strong> <strong>实现泡泡糖的积分规则（定位PRJ-BU2-JAVA-015）</strong></h2><p>核心组件：</p>
<p>UML类图：</p>
<h3 id="6-2-1-获取消除奖励分数"><a href="#6-2-1-获取消除奖励分数" class="headerlink" title="6.2.1 获取消除奖励分数"></a><strong>6.2.1</strong> <strong>获取消除奖励分数</strong></h3><p>根据消除的泡泡糖个数，计算单次消除所获得的奖励分数，如下所示：</p>
<p><strong>getScoreByStars类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int getScoreByStars(int stars) &#123;</span><br><span class="line">    // 计算规则：泡泡糖数量的平方乘以游戏基础分数(LOWER_SCORE)</span><br><span class="line">    int score = stars * stars * ScoreService.LOWER_SCORE;</span><br><span class="line">    return score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="6-2-2-获取结算时奖励分数"><a href="#6-2-2-获取结算时奖励分数" class="headerlink" title="6.2.2 获取结算时奖励分数"></a><strong>6.2.2</strong> <strong>获取结算时奖励分数</strong></h3><p>当界面无可消除泡泡糖时，若剩余泡泡糖数量小于【限定值】，则根据剩余泡泡糖数量进行结算奖励。如下：</p>
<p><strong>getAwardScore类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int getAwardScore(int leftStarNum) &#123;</span><br><span class="line">    int award = 0;</span><br><span class="line">    // 当剩余泡泡糖数量小于奖励限制时，计算奖励分数</span><br><span class="line">    // 奖励规则：基础奖励分数乘以（奖励限制-剩余泡泡糖数量）的平方</span><br><span class="line">    if(leftStarNum &lt; ScoreService.AWARD_LIMIT)&#123;</span><br><span class="line">        award = ScoreService.LOWER_AWARD_SCORE * (ScoreService.AWARD_LIMIT-leftStarNum) * (ScoreService.AWARD_LIMIT-leftStarNum);</span><br><span class="line">    &#125;</span><br><span class="line">    return award;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h3 id="6-2-3-显示通关提示"><a href="#6-2-3-显示通关提示" class="headerlink" title="6.2.3 显示通关提示"></a><strong>6.2.3</strong> <strong>显示通关提示</strong></h3><p>当游戏积分达到通关分数目标时，显示通过提示。</p>
<p><strong>isChangeLevel类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean isChangeLevel(int score) &#123;</span><br><span class="line">    // 获取泡泡糖游戏的分数配置信息，包含当前关卡的通关分数要求</span><br><span class="line">    Score s = this.mConfiguration.getScore();</span><br><span class="line">    // 若当前分数达到或超过当前关卡的通关分数，则满足条件</span><br><span class="line">    if (score &gt;= s.getLevelScore()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 未达到条件，返回false</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>isNoticePassLevel类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isNoticePassLevel(int currentLevel, int score) &#123;</span><br><span class="line">    // 先判断当前分数是否达到关卡升级条件（即通关条件）</span><br><span class="line">    if (isChangeLevel(score)) &#123;</span><br><span class="line">        // 若关卡计数器与当前关卡一致（表示首次达到该关卡通关条件）</span><br><span class="line">        if (this.mLevelCounter == currentLevel) &#123;</span><br><span class="line">            // 将关卡计数器+1，标记为已处理过该关卡的通关提示</span><br><span class="line">            this.mLevelCounter++;</span><br><span class="line">            // 返回true，表示需要显示通关提示</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 非首次触发该关卡通关，无需重复提示</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 未达到通关条件，无需提示</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图所示：</strong></p>
<h1 id="第七章-泡泡糖体验"><a href="#第七章-泡泡糖体验" class="headerlink" title="第七章 泡泡糖体验"></a><strong>第七章</strong> <strong>泡泡糖体验</strong></h1><h2 id="7-1-泡泡糖的体验（定位PRJ-BU2-JAVA-001）"><a href="#7-1-泡泡糖的体验（定位PRJ-BU2-JAVA-001）" class="headerlink" title="7.1 泡泡糖的体验（定位PRJ-BU2-JAVA-001）"></a><strong>7.1 泡泡糖的体验（定位PRJ-BU2-JAVA-001）</strong></h2><h3 id="7-1-1-泡泡糖换肤体验"><a href="#7-1-1-泡泡糖换肤体验" class="headerlink" title="7.1.1 泡泡糖换肤体验"></a><strong>7.1.1</strong> <strong>泡泡糖换肤体验</strong></h3><p>定位src/res.layout/main_layout.fxml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stylesheets=&quot;@../css/skin2.css&quot;</span><br></pre></td></tr></table></figure>
<p><strong>效果如下图所示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stylesheets=&quot;@../css/skin1.css&quot;</span><br></pre></td></tr></table></figure>
<p><strong>效果如下图所示：</strong></p>
<h3 id="7-1-2-Jar命令运行项目"><a href="#7-1-2-Jar命令运行项目" class="headerlink" title="7.1.2 Jar命令运行项目"></a><strong>7.1.2 Jar</strong>命令运行项目</h3><p>A.导出项目 Jar 包，实现游戏的打包与发布</p>
<p>a.选中项目PRJ_BU2_JAVA_001，右键 -&gt; Export。</p>
<p>b.选择Java -&gt; Runnable JAR file，点击Next。</p>
<p>c.在Launch configuration栏中指定启动类：MainClass - PRJ_BU2_JAVA_001。</p>
<p>d.在Export destination一栏，选择需要导出的路径，这里推荐：导出到桌面。</p>
<p>e.导出的文件名称推荐使用：Bubble.jar。</p>
<p>f.点击Finish，导出Bubble.jar包。</p>
<p>B.启动命令提示符窗口</p>
<p>a.Windows 开始菜单 -&gt; 所有程序 -&gt; 附件 -&gt; 命令提示符，点击启动。</p>
<p>C.运行 Jar</p>
<p>a.在命令提示符中输入（注意：尾部有一个空格）java -jar 。</p>
<p>b.将存放于桌面的Bubble.jar直接拖入【命令提示符】。</p>
<p>c.点击回车运行 jar 文件。</p>
<p><strong>注：如果运行不了，切以下命令：</strong></p>
<p><strong>java —module-path</strong> <strong>“D:\cxdownload\javafx-sdk-21.0.2\lib”</strong>（自己目录） <strong>—add-modules javafx.controls,javafx.fxml -jar “C:\Users\lenovo\Desktop\Bubble.jar”</strong></p>
<p><strong>效果如下图所示：</strong></p>
<h1 id="第八章-项目实践的问题与解答（Q-amp-A）"><a href="#第八章-项目实践的问题与解答（Q-amp-A）" class="headerlink" title="第八章 项目实践的问题与解答（Q&amp;A）"></a><strong>第八章</strong> 项目实践的问题与解答（Q&amp;A）</h1><h2 id="Q1-构造函数的作用是什么？项目中你会如何定义构造函数？"><a href="#Q1-构造函数的作用是什么？项目中你会如何定义构造函数？" class="headerlink" title="Q1: 构造函数的作用是什么？项目中你会如何定义构造函数？"></a><strong>Q1:</strong> 构造函数的作用是什么？项目中你会如何定义构造函数？</h2><p>定构造函数用于初始化类中的重要成员变量。</p>
<p>构造函数可以多次重载，默认类具有零参构造函数。</p>
<p>构造函数如为私有作用域，表示该类不能实例化（例如：Utils 类）。</p>
<p>【例如：private MovedStar () {}】</p>
<p>构造函数初始化的变量往往非常重要，并不是所有成员变量都需要在构造函数中初始化。</p>
<p>【例如：人类创建时，需要首先初始化脑袋成员对象，理由是没有脑袋，人存在没有意义。】</p>
<h2 id="Q2-谈谈随机函数-Math-random-的作用与价值。"><a href="#Q2-谈谈随机函数-Math-random-的作用与价值。" class="headerlink" title="Q2: 谈谈随机函数 Math.random 的作用与价值。"></a><strong>Q2:</strong> 谈谈随机函数 Math.random 的作用与价值。</h2><p>定构造函数用于初始化类中的重要成员变量。</p>
<p>Math 类的 random 函数会得到一个【大于等于 0】且【小于 1】的【小数】。</p>
<p>我们一般会将 random 产生的随机结果 * 随机极限值，确保随机上限。</p>
<p>我们一般会将 random 产生的随机结果 + 随机初始值，确保随机下限。</p>
<p><strong>例如：产生 3~10 之间的整数随机值</strong></p>
<p><strong>int result = (int) (Math.random * 8) + 3</strong></p>
<p>随机结果默认为小数，我们可以通过强制类型转换调整随机数的返回结果。</p>
<h2 id="Q3-结合项目谈谈递归函数的运用场景。"><a href="#Q3-结合项目谈谈递归函数的运用场景。" class="headerlink" title="Q3: 结合项目谈谈递归函数的运用场景。"></a><strong>Q3:</strong> 结合项目谈谈递归函数的运用场景。</h2><p>递归函数是指函数对其本身的重复调用，递归函数在使用时需设计明确的 “调用点” 和 “退出点”。 </p>
<p>a.调用点：何时对函数本身执行调用操作，一般调用都是在判断下执行，防止死循环。</p>
<p>b.退出点：递归过程退出点，一般都是调用点条件不满足的情况下，执行退出点。</p>
<p>在<strong>PRJ-BU2-JAVA-004</strong>中，通过搜索同类 “泡泡糖” 执行递归调用，函数名：lookupByPath</p>
<p>调用点：用户点击的 “泡泡糖” 左侧、右侧、上方、下方存在同类 “泡泡糖”。</p>
<p>退出点：当前 “泡泡糖” 左侧、右侧、上方、下方无任何同类 “泡泡糖”。</p>
<h2 id="Q4-请结合项目说明何时使用继承比较妥当？"><a href="#Q4-请结合项目说明何时使用继承比较妥当？" class="headerlink" title="Q4: 请结合项目说明何时使用继承比较妥当？"></a><strong>Q4:</strong> 请结合项目说明何时使用继承比较妥当？</h2><p>继承一般有以下三种情况：</p>
<p>a.继承 JDK 或第三方组件类，实际项目中大多是为了修改父类函数（因父类函数无法满足要求）。</p>
<p>【例如：Java 的 JDK 为程序员提供了集合，集合可以存放任意数据，但当前游戏中，集合需要存放泡泡糖，JDK 的集合并不是为 “泡泡糖” 而生的，所以我们编写了 StarList 继承了 JDK 的集合，并修改了 List 中无法满足要求的函数（例如：indexOf 等），如感兴趣可以查看 StarList 类。】</p>
<p>b.继承 JDK 或第三方组件类，完全获取父类的功能。</p>
<p>【例如：当前游戏中，还记得《消灭泡泡糖》的界面吗？我们无需开发如此复杂的 Windows 窗体界面，只需要在代码中继承 JDK 为我们提供的 Application 类就可以实现一个完整窗体。】</p>
<p>c.如<strong>PRJ-BU2-JAVA-005</strong>，实现类间属性扩展。</p>
<p>【说明：Star 具有两个描述属性：位置，颜色（类型），当 Star 因为消除操作需要移动时，Star 将产生一个新位置，此处 MovedStar 的出现就是为了确定移动后 Star 的位置，同时它具有 Star 的所有属性。】</p>
<h2 id="Q5-谈谈接口的作用，并说明在您所开发的项目中如何定义与设计接口？"><a href="#Q5-谈谈接口的作用，并说明在您所开发的项目中如何定义与设计接口？" class="headerlink" title="Q5: 谈谈接口的作用，并说明在您所开发的项目中如何定义与设计接口？"></a><strong>Q5:</strong> 谈谈接口的作用，并说明在您所开发的项目中如何定义与设计接口？</h2><p>接口有两大作用：定标准、解耦合。</p>
<p>a.定标准，业务调用方允许设定业务规范，只有满足业务标准的组件才可以与调用方交互（多用于系统架构设计）。</p>
<p>b. 解耦合，原本只能一人开发的系统，降耦合后可以由多人同时开发，最后组装。</p>
<p>【例如：当前场景通过接口StarService将界面和业务彻底隔离，界面层只负责显示 “泡泡糖”，“泡泡糖” 的消除、移动、计算全部由业务层负责。】</p>
<p>由于界面层需要调用获取业务层计算结果后才可以显示 “泡泡糖”，因此界面层扮演接口调用方，业务层扮演接口实现方，具体为：</p>
<p>StarService使原本一人自顶向下的开发模式，变成了多人并行开发，1 人负责界面，1 人负责业务。</p>
<p>扩展：层与层之间的数据交互，一般需要通过对象来实现，当前系统的数据交互对象是StarList，1 个StarList中可以存放多个Star。</p>
<h2 id="Q6-谈谈集合泛型的作用"><a href="#Q6-谈谈集合泛型的作用" class="headerlink" title="Q6: 谈谈集合泛型的作用"></a><strong>Q6:</strong> 谈谈集合泛型的作用</h2><p>由于 Java 集合中的 ArrayList 和 HashMap 都允许存放任意数据类型的数据，因此为集合配套泛型可以规范集合数据类型，保证集合中的数据类型一致（实际项目不可能允许集合中的数据类型不一致）。</p>
<p>泛型有语法约束性，强制限定数据类型的完整性。</p>
<p>扩展：泛型不仅仅可以在集合中使用，您自己编写的类也可以配套泛型，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ExcelManager&lt;S&gt; &#123;</span><br><span class="line">    public void saveDataToSheet(S datasources) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExcelManager&lt;ArrayList&lt;String&gt;&gt; manager = new ExcelManager&lt;ArrayList&lt;String&gt;&gt;();</span><br><span class="line">ExcelManager&lt;DataBean&gt; manager = new ExcelManager&lt;DataBean&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Q7-以PRJ-BU2-JAVA-015为例，谈谈-Java-中按值传递数据与按引用传递数据的区别？"><a href="#Q7-以PRJ-BU2-JAVA-015为例，谈谈-Java-中按值传递数据与按引用传递数据的区别？" class="headerlink" title="Q7: 以PRJ-BU2-JAVA-015为例，谈谈 Java 中按值传递数据与按引用传递数据的区别？"></a><strong>Q7:</strong> <strong>以</strong>PRJ-BU2-JAVA-015<strong>为例，谈谈 Java 中按值传递数据与按引用传递数据的区别？</strong></h2><p>Java 中八种原始数据类型都是按值传递（byte、short、int、long、float、double、boolean、char）。</p>
<p>按值传递就是，原始数据类型利用 “=” 赋值时，变量与变量之间只通过数据交换。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int row = 10;</span><br><span class="line">int r = row;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上语句的含义是创建一个整型变量内存空间，取名 row 并赋值 10，再创建一个整型变量内存空间，取名 r。将 row 空间的数据赋值给 r 空间，row 和 r 完全是两个不同的内存空间。</p>
<p>按值传递的场景应用效果如下：</p>
<p>上图一共有三个 row 变量和三个 col 变量，分别存在于 createStars、move、setPosition 中。</p>
<p> 当createStars 调用 move 时，只是将自己的 row 变量值和 col 变量值传送给了 move 函数。</p>
<p>虽然move 对 row 和 col 执行了 ++ 操作，但是 createStars 的 row 和 col 并没有受到影响</p>
<p>createStars 再次调用 setPosition 时，row 和 col 仍然等于 0，“泡泡糖” 肯定不会移动。</p>
<p>Java中的三种引用数据类型都是按引用传递的（对象、接口、数组）。</p>
<p>按引用传递就是，原始引用类型利用 “=” 赋值时，多个引用对象名指代的是同一个内存空间。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Position p = new Position();</span><br><span class="line">Position pos = p;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上语句的含义是：new Position();创建的内存空间，分别被取名为 “p” 和 “pos”，操作 “p” 或 “pos” 其实访问的是同一块内存空间，这个与值类型差别是非常大的。</p>
<p>按引用传递的场景应用效果如下：</p>
<p>上图只有一个position对象，虽然分散在createStars、move、setPosition中，其实指代的是同一块内存。</p>
<p>【重要提示】：函数的 “形式”、“实际”“参数间” 隐藏了 “个 =”，不理解时，可假设 “=”，再理解表达式。</p>
<p>【重要提示】：变量名在不同作用域中可以完全相同。</p>
<h1 id="第九章-实践项目总结"><a href="#第九章-实践项目总结" class="headerlink" title="第九章 实践项目总结"></a><strong>第九章</strong> 实践项目总结</h1><h2 id="9-1-递归函数的作用及注意点"><a href="#9-1-递归函数的作用及注意点" class="headerlink" title="9.1 递归函数的作用及注意点"></a><strong>9.1</strong> <strong>递归函数的作用及注意点</strong></h2><p>在PRJ-BU2-JAVA-004中，递归函数核心为<code>lookupByPath</code>函数，作用是实现“查找被点击泡泡糖四周同色泡泡糖”的核心需求：以被点击泡泡糖为基准，向左侧、右侧、顶部、底部四个方向逐层查找同色泡泡糖，找到同色泡泡糖后，会以其为新基准继续调用自身查找，直至无同色泡泡糖，确保将所有相连的同色泡泡糖纳入“待消除泡泡糖集合”，满足游戏消除逻辑，同时避免重复编写多方向查找代码，简化实现逻辑。</p>
<p>使用时需注意两点：一是必须明确“调用点”与“退出点”，调用点为“被点击泡泡糖的左/右/上/下存在同色且未在待消除集合中的泡泡糖”，退出点包括超10×10矩阵边界、目标位置无泡泡糖、泡泡糖不同色、泡泡糖已在待消除集合，防止死循环；二是需控制递归范围，仅在矩阵内查找相连同色泡泡糖，避免无意义递归影响性能。</p>
<h2 id="9-2-枚举类型的作用及应用"><a href="#9-2-枚举类型的作用及应用" class="headerlink" title="9.2 枚举类型的作用及应用"></a><strong>9.2</strong> 枚举类型的作用及应用</h2><p>作用：</p>
<p>a.提升代码可读性，将无意义的数值转化为有业务含义的常量，降低软件后期维护成本，避免因直接用数值导致理解混淆。</p>
<p>b.保障类型安全，枚举取值为预定义固定常量，无法随意创建新实例，确保变量赋值始终在合法范围内，比如限制泡泡糖类型仅为预设的 5 种</p>
<p>应用（PRJ-BU2-JAVA-002）：</p>
<p>a.在Star类中定义StarType枚举，通过私有构造函数为枚举常量赋值value（如BLUE(0)“蓝色空心圆”、GREEN(1)“绿色圆角” 等 5 种，对应泡泡糖外观），并添加value()方法实现 “枚举值→数值” 转换，添加静态valueOf(int num)方法（通过switch-case）实现 “数值→枚举值” 转换。</p>
<p>b.将StarType作为Star类的type成员变量类型，描述泡泡糖外观，配合get/set访问器赋值获取，如创建star2时指定type为StarType.GREEN，同时支持界面根据枚举值渲染泡泡糖外观、业务层处理数据交互。</p>
<h2 id="9-3-JavaFX实现游戏界面"><a href="#9-3-JavaFX实现游戏界面" class="headerlink" title="9.3 JavaFX实现游戏界面"></a><strong>9.3 JavaFX</strong>实现游戏界面</h2><p>（PRJ-BU2-JAVA-006）围绕JavaFX实现泡泡糖游戏界面展开，让学习者掌握了相关核心流程。首先需搭建开发环境，创建JavaFX应用程序类；接着运用布局管理、控件使用和图形绘制等UI技术设计游戏界面，其中关键是将业务层的泡泡糖数据（Star对象）通过属性映射转换为Label控件，并设置其尺寸、位置、样式等；然后集成游戏逻辑与界面；之后进行测试调试以验证显示效果，包括测试阶段用固定数据、真实阶段用随机数据；还需优化性能，最后完成打包分发。整个过程体现了JavaFX图形与UI组件的应用，具体实现需依游戏需求等灵活调整。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://bistutzyy.github.io">bistutzyy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://bistutzyy.github.io/2025/09/22/%E6%B3%A1%E6%B3%A1%E7%B3%96/">https://bistutzyy.github.io/2025/09/22/%E6%B3%A1%E6%B3%A1%E7%B3%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/09/09/%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%B0%8F%E6%B8%B8%E6%88%8F/" title="泡泡糖小游戏——Java尝试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">泡泡糖小游戏——Java尝试</div></div><div class="info-2"><div class="info-item-1">学校让写的项目，总结一下</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bistutzyy</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/bistutzyy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bistutzyy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:173236231@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">第一章 需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 项目设计思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%8F%AF%E7%8E%A9%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1**可玩性**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E5%8F%AF%E8%A7%86%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 可视性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%8E%A9%E5%AE%B6%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 玩家分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">第二章 概要设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 设计思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BB%A5%E5%8F%8A%E9%87%8D%E7%82%B9UML%E7%B1%BB%E5%9B%BE%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 游戏流程与整体框架（以及重点UML类图）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 游戏流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 整体框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E9%87%8D%E7%82%B9UML%E7%B1%BB%E5%9B%BE%E5%B1%95%E7%A4%BA"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 重点UML类图展示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%9A%84%E6%98%BE%E7%A4%BA"><span class="toc-number">3.</span> <span class="toc-text">第三章 泡泡糖的显示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%98%BE%E7%A4%BA%E6%B3%A1%E6%B3%A1%E7%B3%96%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-002%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 显示泡泡糖（定位PRJ-BU2-JAVA-002）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%88%9B%E5%BB%BA%E3%80%8A%E6%B6%88%E7%81%AD%E6%B3%A1%E6%B3%A1%E7%B3%96%E3%80%8B%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 创建《消灭泡泡糖》实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E4%BC%98%E5%8C%96%E3%80%8A%E6%B6%88%E7%81%AD%E6%B3%A1%E6%B3%A1%E7%B3%96%E3%80%8B%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 优化《消灭泡泡糖》实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2%E5%91%88%E7%8E%B0%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3 游戏界面呈现泡泡糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%9A%8F%E6%9C%BA%E6%98%BE%E7%A4%BA%E6%B3%A1%E6%B3%A1%E7%B3%96%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-003%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 随机显示泡泡糖（定位PRJ-BU2-JAVA-003）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E6%98%BE%E7%A4%BA%E4%B8%80%E8%A1%8C%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 显示一行泡泡糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E6%98%BE%E7%A4%BA10-10%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%9F%A9%E9%98%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 显示10 * 10泡泡糖矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E9%9A%8F%E6%9C%BA%E6%98%BE%E7%A4%BA10-10%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%9F%A9%E9%98%B5"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 随机显示10 * 10泡泡糖矩阵</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%9A%84%E6%98%BE%E7%A4%BA"><span class="toc-number">4.</span> <span class="toc-text">第四章 泡泡糖的显示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%8E%B7%E5%BE%97%E5%BE%85%E6%B6%88%E9%99%A4%E7%9A%84%E6%B3%A1%E6%B3%A1%E7%B3%96-%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-004%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 获得待消除的泡泡糖 （定位PRJ-BU2-JAVA-004）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%85%8B%E9%9A%86%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 泡泡糖克隆函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%B7%A6%E4%BE%A7%E5%90%8C%E8%89%B2%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 查询某个泡泡糖左侧同色泡泡糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%8F%B3%E4%BE%A7%E5%90%8C%E8%89%B2%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 查询某个泡泡糖右侧同色泡泡糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%B3%A1%E6%B3%A1%E7%B3%96%E9%A1%B6%E9%83%A8%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4 查询某个泡泡糖顶部泡泡糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%BA%95%E9%83%A8%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">4.1.5.</span> <span class="toc-text">4.1.5 查询某个泡泡糖底部泡泡糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%B0%81%E8%A3%85%E5%BE%85%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%B3%A1%E6%B3%A1%E7%B3%96%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-005%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 封装待移动的泡泡糖（定位PRJ-BU2-JAVA-005）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%88%9B%E5%BB%BA%E5%BE%85%E7%A7%BB%E5%8A%A8%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 创建待移动泡泡糖实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E6%96%87%E6%9C%AC%E5%8C%96%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 实体类的文本化输出函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%B0%81%E8%A3%85"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 实现移动泡泡糖封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%BD%93%E9%AA%8C%E6%8E%A5%E5%8F%A3%E8%A7%A3%E8%80%A6%E7%89%B9%E6%80%A7%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-006%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 体验接口解耦特性（定位PRJ-BU2-JAVA-006）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 创建服务测试类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2%E6%B3%A1%E6%B3%A1%E7%B3%96%E6%98%BE%E7%A4%BA%E5%8F%8A%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E6%8E%A5%E5%8F%A3%E5%88%87%E6%8D%A2"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 实现界面泡泡糖显示及通过动态接口切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%BD%93%E9%AA%8C%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-007%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 体验接口隔离性（定位PRJ-BU2-JAVA-007）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%A4%84%E7%90%86%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1 处理泡泡糖点击事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB-%E6%B6%88%E9%99%A4%E6%95%88%E6%9E%9C%EF%BC%88%E4%B8%8D%E8%80%83%E8%99%91%E7%A7%BB%E5%8A%A8%EF%BC%89"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2 实现点击-消除效果（不考虑移动）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%9A%84%E7%A7%BB%E5%8A%A8"><span class="toc-number">5.</span> <span class="toc-text">第五章 泡泡糖的移动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%A7%BB%E5%8A%A8%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E7%9A%84%E6%B3%A1%E6%B3%A1%E7%B3%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-010%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 移动垂直方向的泡泡糖（一）（定位PRJ-BU2-JAVA-010）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 交换两个泡泡糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E6%B3%A1%E6%B3%A1%E7%B3%96%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 泡泡糖集合的排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E7%A7%BB%E5%8A%A8%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E7%9A%84%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3 移动垂直方向的泡泡糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%A7%BB%E5%8A%A8%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E7%9A%84%E6%B3%A1%E6%B3%A1%E7%B3%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-011%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 移动垂直方向的泡泡糖（二）（定位PRJ-BU2-JAVA-011）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E6%A0%B9%E6%8D%AE%E5%9D%90%E6%A0%87%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%9F%A5%E6%89%BE%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1根据坐标和位置查找泡泡糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E5%88%A4%E6%96%AD%E6%B3%A1%E6%B3%A1%E7%B3%96%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 判断泡泡糖是否存在</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%A7%BB%E5%8A%A8%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E6%B3%A1%E6%B3%A1%E7%B3%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-012%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 移动垂直方向上的泡泡糖（三）（定位PRJ-BU2-JAVA-012）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E6%9B%B4%E6%96%B0%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 更新集合的排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%BE%85%E6%B6%88%E9%99%A4%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%9A%84%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E7%BB%84"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2 待消除泡泡糖的排序与分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E8%8E%B7%E5%8F%96%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E5%BE%85%E7%A7%BB%E5%8A%A8%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3 获取垂直方向待移动泡泡糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E7%A7%BB%E5%8A%A8%E6%B0%B4%E5%B9%B3%E6%96%B9%E5%90%91%E7%9A%84%E6%B3%A1%E6%B3%A1%E7%B3%96%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-013%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 移动水平方向的泡泡糖（定位PRJ-BU2-JAVA-013）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E8%8E%B7%E5%8F%96%E8%A2%AB%E6%95%B4%E5%88%97%E6%B8%85%E7%A9%BA%E7%9A%84%E6%B3%A1%E6%B3%A1%E7%B3%96%E9%9B%86%E5%90%88"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 获取被整列清空的泡泡糖集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E8%8E%B7%E5%8F%96%E6%B0%B4%E5%B9%B3%E5%BE%85%E7%A7%BB%E5%8A%A8%E6%B3%A1%E6%B3%A1%E7%B3%96"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 获取水平待移动泡泡糖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%9A%E5%85%B3%E5%88%86%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86"><span class="toc-number">6.</span> <span class="toc-text">第六章 通关分数与积分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%9B%B4%E6%96%B0%E5%85%B3%E5%8D%A1%E9%80%9A%E5%85%B3%E5%88%86%E6%95%B0%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-014%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 更新关卡通关分数（定位PRJ-BU2-JAVA-014）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E8%8E%B7%E5%8F%96%E5%88%9D%E5%A7%8B%E9%80%9A%E5%85%B3%E5%88%86%E6%95%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1 获取初始通关分数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E6%9B%B4%E6%96%B0%E5%85%B3%E5%8D%A1%E9%80%9A%E5%85%B3%E5%88%86%E6%95%B0"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2 更新关卡通关分数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%AE%9E%E7%8E%B0%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%9A%84%E7%A7%AF%E5%88%86%E8%A7%84%E5%88%99%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-015%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 实现泡泡糖的积分规则（定位PRJ-BU2-JAVA-015）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E8%8E%B7%E5%8F%96%E6%B6%88%E9%99%A4%E5%A5%96%E5%8A%B1%E5%88%86%E6%95%B0"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 获取消除奖励分数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E8%8E%B7%E5%8F%96%E7%BB%93%E7%AE%97%E6%97%B6%E5%A5%96%E5%8A%B1%E5%88%86%E6%95%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 获取结算时奖励分数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E6%98%BE%E7%A4%BA%E9%80%9A%E5%85%B3%E6%8F%90%E7%A4%BA"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3 显示通关提示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%B3%A1%E6%B3%A1%E7%B3%96%E4%BD%93%E9%AA%8C"><span class="toc-number">7.</span> <span class="toc-text">第七章 泡泡糖体验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%B3%A1%E6%B3%A1%E7%B3%96%E7%9A%84%E4%BD%93%E9%AA%8C%EF%BC%88%E5%AE%9A%E4%BD%8DPRJ-BU2-JAVA-001%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 泡泡糖的体验（定位PRJ-BU2-JAVA-001）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E6%B3%A1%E6%B3%A1%E7%B3%96%E6%8D%A2%E8%82%A4%E4%BD%93%E9%AA%8C"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1 泡泡糖换肤体验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-Jar%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2 Jar命令运行项目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E7%AD%94%EF%BC%88Q-amp-A%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">第八章 项目实践的问题与解答（Q&amp;A）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Q1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">Q1: 构造函数的作用是什么？项目中你会如何定义构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q2-%E8%B0%88%E8%B0%88%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0-Math-random-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E4%BB%B7%E5%80%BC%E3%80%82"><span class="toc-number">8.2.</span> <span class="toc-text">Q2: 谈谈随机函数 Math.random 的作用与价值。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q3-%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E8%B0%88%E8%B0%88%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82"><span class="toc-number">8.3.</span> <span class="toc-text">Q3: 结合项目谈谈递归函数的运用场景。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q4-%E8%AF%B7%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%E6%AF%94%E8%BE%83%E5%A6%A5%E5%BD%93%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">Q4: 请结合项目说明何时使用继承比较妥当？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q5-%E8%B0%88%E8%B0%88%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%9C%A8%E6%82%A8%E6%89%80%E5%BC%80%E5%8F%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">Q5: 谈谈接口的作用，并说明在您所开发的项目中如何定义与设计接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q6-%E8%B0%88%E8%B0%88%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.6.</span> <span class="toc-text">Q6: 谈谈集合泛型的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q7-%E4%BB%A5PRJ-BU2-JAVA-015%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%B0%88%E8%B0%88-Java-%E4%B8%AD%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">Q7: 以PRJ-BU2-JAVA-015为例，谈谈 Java 中按值传递数据与按引用传递数据的区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">第九章 实践项目总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 递归函数的作用及注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 枚举类型的作用及应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-JavaFX%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 JavaFX实现游戏界面</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/22/%E6%B3%A1%E6%B3%A1%E7%B3%96/" title="Untitled">Untitled</a><time datetime="2025-09-22T15:13:00.760Z" title="Created 2025-09-22 23:13:00">2025-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/09/%E6%B3%A1%E6%B3%A1%E7%B3%96%E5%B0%8F%E6%B8%B8%E6%88%8F/" title="泡泡糖小游戏——Java尝试">泡泡糖小游戏——Java尝试</a><time datetime="2025-09-09T03:25:22.082Z" title="Created 2025-09-09 11:25:22">2025-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/28/%E5%BE%A1%E5%9D%82%E7%BE%8E%E7%90%B4/" title="御坂美琴"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/%E5%BE%A1%E5%9D%82%E7%BE%8E%E7%90%B4250828%E5%8D%9A%E5%AE%A2/OIP-C.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="御坂美琴"/></a><div class="content"><a class="title" href="/2025/08/28/%E5%BE%A1%E5%9D%82%E7%BE%8E%E7%90%B4/" title="御坂美琴">御坂美琴</a><time datetime="2025-08-28T03:31:55.253Z" title="Created 2025-08-28 11:31:55">2025-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/28/%E7%99%BD%E9%93%B6%E5%BE%A1%E8%A1%8C/" title="只有受到眷顾的人，才能毫不掩饰"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/e04d08f52b66e9f4b7e96de9a22f50d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="只有受到眷顾的人，才能毫不掩饰"/></a><div class="content"><a class="title" href="/2025/02/28/%E7%99%BD%E9%93%B6%E5%BE%A1%E8%A1%8C/" title="只有受到眷顾的人，才能毫不掩饰">只有受到眷顾的人，才能毫不掩饰</a><time datetime="2025-02-28T02:04:04.586Z" title="Created 2025-02-28 10:04:04">2025-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/22/%E5%BC%B9%E5%B9%95%E6%8F%92%E4%BB%B6/" title="不用上b站也可以看弹幕"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tzyy-1330068502.cos.ap-beijing.myqcloud.com/665200d08d44f05d5bda654cd6144bb.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="不用上b站也可以看弹幕"/></a><div class="content"><a class="title" href="/2025/02/22/%E5%BC%B9%E5%B9%95%E6%8F%92%E4%BB%B6/" title="不用上b站也可以看弹幕">不用上b站也可以看弹幕</a><time datetime="2025-02-22T12:01:50.815Z" title="Created 2025-02-22 20:01:50">2025-02-22</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By bistutzyy</span></div><div class="footer_custom_text">Hello,welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://vercel-zeta-eight-46.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script>(() => {
  btf.getScript('//code.tidio.co/kw2uvlikubnt1sb2rkcrlkpa219lzwz0.js').then(() => {
    const isChatBtn = false
    const isChatHideShow = false

    if (isChatBtn) {
      let isShow = false
      const close = () => {
        window.tidioChatApi.hide()
        isShow = false
      }
      
      const open = () => {
        window.tidioChatApi.open()
        window.tidioChatApi.show()
        isShow = true
      }

      const onTidioChatApiReady = () => {
        window.tidioChatApi.hide()
        window.tidioChatApi.on("close", close)
      }
      if (window.tidioChatApi) {
        window.tidioChatApi.on("ready", onTidioChatApiReady)
      } else {
        document.addEventListener("tidioChat-ready", onTidioChatApiReady)
      }

      window.chatBtnFn = () => {
        if (!window.tidioChatApi) return
        isShow ? close() : open()
      }

      document.getElementById('chat-btn').style.display = 'block'

    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => window.tidioChatApi && window.tidioChatApi.hide(),
        show: () => window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'AVQAENZ4QB',
    apiKey: '1797494608c4d2e528b97d2fdc665c4b',
    indexName: 'bistutzyyio',
    container: '#docsearch',
    placeholder: 'Search for Posts',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>